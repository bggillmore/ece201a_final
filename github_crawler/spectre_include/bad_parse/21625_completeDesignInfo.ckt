////////////////////////////////////////////////////////////////////////
// PLEASE DO NOT EDIT OR COMPILE THIS FILE.                             
// IT IS MEANT FOR VIEWING PURPOSE ONLY.                                
// 
// All files for configuration: (16nm_Tests MC_6TWrite_Test ams_config)
////////////////////////////////////////////////////////////////////////


// 
// Design File for: (16nm_Tests MC_6TWrite_Test schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module MC_6TWrite_Test (  ); 


wire [3:0] W1_1;
wire [3:0] B1_1;
wire [63:0] Aline;
wire [0:3] net15;
wire [3:0] \~R1_1 ;
wire [3:0] \~R0_1 ;
wire [7:0] S;
 
 
 
\6T_CHUNK  (*
integer library_binding = "16nm";
 *)
ICHUNK ( .B1( 
B1_1[3:0] ), .B0( { cds_globals.\gnd! ,
 cds_globals.\gnd! , cds_globals.\gnd! , cds_globals.\gnd!  } ), .A( 
Aline[63:0] ), .Go( cds_globals.\gnd!  ), .W1( W1_1[3:0] ), .W0( { cds_globals.\gnd! ,
 cds_globals.\gnd! , cds_globals.\gnd! , cds_globals.\gnd!  } ), .S( 
S[7:0] ), .\~R1 ( \~R1_1 [3:0] ), .\~R0 ( \~R0_1 [3:0] ) );
 
vpwl #(.t1(0), .acm(0), .t2(cds_globals.time2), .t3(cds_globals.time3),
 .t4(cds_globals.time4), .v1(0), .t5(cds_globals.time5), .v2(0), .v3(cds_globals.vdd),
 .acp(0), .v4(cds_globals.vdd), .tvpairs(5)) (*
integer 
library_binding = "UCD_Analog_Parts";
 *)
V2 ( .PLUS( Aline[0] ), .MINUS( 
cds_globals.\gnd!  ) );
vpwl #(.t1(0), .acm(0), .t2(cds_globals.time2), .t3(cds_globals.time3),
 .t4(cds_globals.time4), .v1(0), .t5(cds_globals.time5), .v2(0), .v3(cds_globals.vdd),
 .acp(0), .v4(cds_globals.vdd), .tvpairs(5)) (*
integer 
library_binding = "UCD_Analog_Parts";
integer elaboration_binding
 = "V7[3:0]";
 *)
V7_3 ( .PLUS( B1_1[3] ), .MINUS( cds_globals.\gnd!  ) ),
  V7_2 ( .PLUS( B1_1[2] ), .MINUS( cds_globals.\gnd!  ) ),
  V7_1 ( .PLUS( B1_1[1] ), .MINUS( cds_globals.\gnd!  ) ),
  V7_0 ( .PLUS( B1_1[0] ), .MINUS( cds_globals.\gnd!  ) );
vpwl #(.t1(0), .acm(0), .t2(cds_globals.time2), .t3(cds_globals.time3),
 .t4(cds_globals.time4), .v1(0), .t5(cds_globals.time5), .v2(0), .v3(cds_globals.vdd),
 .acp(0), .v4(cds_globals.vdd), .tvpairs(5)) (*
integer 
library_binding = "UCD_Analog_Parts";
integer elaboration_binding
 = "V8[3:0]";
 *)
V8_3 ( .PLUS( W1_1[3] ), .MINUS( cds_globals.\gnd!  ) ),
  V8_2 ( .PLUS( W1_1[2] ), .MINUS( cds_globals.\gnd!  ) ),
  V8_1 ( .PLUS( W1_1[1] ), .MINUS( cds_globals.\gnd!  ) ),
  V8_0 ( .PLUS( W1_1[0] ), .MINUS( cds_globals.\gnd!  ) );
vpwl #(.t1(0), .acm(0), .t2(cds_globals.time2), .t3(cds_globals.time3),
 .t4(cds_globals.time4), .v1(0), .t5(cds_globals.time5), .v2(0), .acp(0),
 .v3(cds_globals.vdd), .v4(cds_globals.vdd), .tvpairs(5)) (*
integer 
library_binding = "UCD_Analog_Parts";
 *)
V6 ( .PLUS( S[0] ), .MINUS( 
cds_globals.\gnd!  ) );
 
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
integer elaboration_binding = "M0[3:0]";
 *)
M0_3 ( \~R1_1 [3], 
net15[0], cds_globals.\vdd! , cds_globals.\vdd!  ),
  M0_2 ( \~R1_1 [2], net15[1], cds_globals.\vdd! , cds_globals.\vdd!  ),
  M0_1 ( \~R1_1 [1], net15[2], cds_globals.\vdd! , cds_globals.\vdd!  ),
  M0_0 ( \~R1_1 [0], net15[3], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
integer elaboration_binding = "M1[3:0]";
 *)
M1_3 ( \~R0_1 [3], 
net15[0], cds_globals.\vdd! , cds_globals.\vdd!  ),
  M1_2 ( \~R0_1 [2], net15[1], cds_globals.\vdd! , cds_globals.\vdd!  ),
  M1_1 ( \~R0_1 [1], net15[2], cds_globals.\vdd! , cds_globals.\vdd!  ),
  M1_0 ( \~R0_1 [0], net15[3], cds_globals.\vdd! , cds_globals.\vdd!  );
 
vdc #(.vdc(cds_globals.vdd)) (*
integer library_binding
 = "UCD_Analog_Parts";
 *)
V0 ( .PLUS( cds_globals.\vcc!  ), .MINUS( 
cds_globals.\gnd!  ) );
vdc #(.vdc(cds_globals.vdd)) (*
integer library_binding
 = "UCD_Analog_Parts";
 *)
V1 ( .PLUS( cds_globals.\vdd!  ), .MINUS( 
cds_globals.\gnd!  ) );
 
inv_1x (*
integer library_binding = "16nm";
integer 
elaboration_binding = "I4[3:0]";
 *)
I4_3 ( .Y( cds_globals.\gnd!  ), 
.A( \~R1_1 [3] ) ),
  I4_2 ( .Y( cds_globals.\gnd!  ), .A( \~R1_1 [2] ) ),
  I4_1 ( .Y( cds_globals.\gnd!  ), .A( \~R1_1 [1] ) ),
  I4_0 ( .Y( cds_globals.\gnd!  ), .A( \~R1_1 [0] ) );
inv_1x (*
integer library_binding = "16nm";
integer 
elaboration_binding = "I6[3:0]";
 *)
I6_3 ( .Y( cds_globals.\gnd!  ), 
.A( \~R0_1 [3] ) ),
  I6_2 ( .Y( cds_globals.\gnd!  ), .A( \~R0_1 [2] ) ),
  I6_1 ( .Y( cds_globals.\gnd!  ), .A( \~R0_1 [1] ) ),
  I6_0 ( .Y( cds_globals.\gnd!  ), .A( \~R0_1 [0] ) );

endmodule

// 
// Design File for: (16nm 6T_CHUNK schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module \6T_CHUNK  ( \~R0 ,\~R1 ,A,B0,B1,S,W0,
W1,Go ); 

inout [3:0]  \~R0 ;
inout [3:0]  \~R1 ;
inout [63:0]  A;
inout [3:0] 
 B0;
inout [3:0]  B1;
inout [7:0]  S;
inout [3:0]  W0;
inout [3:0] 
 W1;
inout   Go;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
 
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY7 ( .SM0( 
SM0_1_bit3 ), .SM1( SM1_1_bit3 ), .B1( B1[3] ), .B0( B0[3] ), .A( 
A[63:32] ), .W1( W1[3] ), .W0( W0[3] ), .S( S[7:4] ) );
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY6 ( .SM0( 
SM0_1_bit2 ), .SM1( SM1_1_bit2 ), .B1( B1[2] ), .B0( B0[2] ), .A( 
A[63:32] ), .W1( W1[2] ), .W0( W0[2] ), .S( S[7:4] ) );
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY5 ( .SM0( 
SM0_1_bit1 ), .SM1( SM1_1_bit1 ), .B1( B1[1] ), .B0( B0[1] ), .A( 
A[63:32] ), .W1( W1[1] ), .W0( W0[1] ), .S( S[7:4] ) );
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY4 ( .SM0( 
SM0_1_bit0 ), .SM1( SM1_1_bit0 ), .B1( B1[0] ), .B0( B0[0] ), .A( 
A[63:32] ), .W1( W1[0] ), .W0( W0[0] ), .S( S[7:4] ) );
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY3 ( .SM0( 
SM0_0_bit3 ), .SM1( SM1_0_bit3 ), .B1( B1[3] ), .B0( B0[3] ), .A( 
A[31:0] ), .W1( W1[3] ), .W0( W0[3] ), .S( S[3:0] ) );
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY2 ( .SM0( 
SM0_0_bit2 ), .SM1( SM1_0_bit2 ), .B1( B1[2] ), .B0( B0[2] ), .A( 
A[31:0] ), .W1( W1[2] ), .W0( W0[2] ), .S( S[3:0] ) );
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY1 ( .SM0( 
SM0_0_bit1 ), .SM1( SM1_0_bit1 ), .B1( B1[1] ), .B0( B0[1] ), .A( 
A[31:0] ), .W1( W1[1] ), .W0( W0[1] ), .S( S[3:0] ) );
\6T_32x4  (*
integer library_binding = "16nm";
 *)
IARRAY0 ( .SM0( 
SM0_0_bit0 ), .SM1( SM1_0_bit0 ), .B1( B1[0] ), .B0( B0[0] ), .A( 
A[31:0] ), .W1( W1[0] ), .W0( W0[0] ), .S( S[3:0] ) );
 
\6T_SetRead  (*
integer library_binding = "16nm";
 *)
I7 ( .SM0( { SM0_1_bit3,
SM0_0_bit3 } ), .SM1( { SM1_1_bit3,SM1_0_bit3 } ), .Go( Go ), .\~R1 ( 
\~R1 [3] ), .\~R0 ( \~R0 [3] ) );
\6T_SetRead  (*
integer library_binding = "16nm";
 *)
I6 ( .SM0( { SM0_1_bit2,
SM0_0_bit2 } ), .SM1( { SM1_1_bit2,SM1_0_bit2 } ), .Go( Go ), .\~R1 ( 
\~R1 [2] ), .\~R0 ( \~R0 [2] ) );
\6T_SetRead  (*
integer library_binding = "16nm";
 *)
I5 ( .SM0( { SM0_1_bit1,
SM0_0_bit1 } ), .SM1( { SM1_1_bit1,SM1_0_bit1 } ), .Go( Go ), .\~R1 ( 
\~R1 [1] ), .\~R0 ( \~R0 [1] ) );
\6T_SetRead  (*
integer library_binding = "16nm";
 *)
I4 ( .SM0( { SM0_1_bit0,
SM0_0_bit0 } ), .SM1( { SM1_1_bit0,SM1_0_bit0 } ), .Go( Go ), .\~R1 ( 
\~R1 [0] ), .\~R0 ( \~R0 [0] ) );

endmodule

// 
// Design File for: (16nm 6T_32x4 schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module \6T_32x4  ( SM0,SM1,B1,B0,A,W1,W0,S ); 

output   SM0;
output   SM1;
inout   B1;
inout   B0;
inout [31:0]  A;

inout   W1;
inout   W0;
inout [3:0]  S;

wire B0_nandC;
wire B0_Pass2;
wire B0_nandB;
wire B1_Pass1;
wire B1_Pass0;
wire B1_nandA;
wire B1_Pass3;
wire B1_nandC;
wire B1_Pass2;
wire B1_nandB;
wire B1_nandD;
wire B0_nandD;
wire B0_Pass1;
wire B0_nandA;
wire B0_Pass0;
wire B0_Pass3;
 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_0 (B0_nandC, B0P3);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_1 (B0_Pass2, B0P3);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_2 (B0_nandB, B0P2);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_3 (B1_Pass1, B1P2);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_4 (B1_Pass0, B1P1);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_5 (B1_nandA, B1P1);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_6 (B1_Pass3, B1P4);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_7 (B1_nandC, B1P3);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_8 (B1_Pass2, B1P3);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_9 (B1_nandB, B1P2);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_10 (B1_nandD, B1P4);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_11 (B0_nandD, B0P4);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_12 (B0_Pass1, B0P2);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_13 (B0_nandA, B0P1);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_14 (B0_Pass0, B0P1);
cds_alias #(.width(1)) (*
integer library_binding = "basic";
integer 
view_binding = "functional";
 *)
ams_alias_inst_15 (B0_Pass3, B0P4);
 
\6T_32x  (*
integer library_binding = "16nm";
 *)
ISRAM3 ( .B1( B1P4 ), 
.B0( B0P4 ), .A( A[31:0] ) );
\6T_32x  (*
integer library_binding = "16nm";
 *)
ISRAM1 ( .B1( B1P2 ), 
.B0( B0P2 ), .A( A[31:0] ) );
\6T_32x  (*
integer library_binding = "16nm";
 *)
ISRAM2 ( .B1( B1P3 ), 
.B0( B0P3 ), .A( A[31:0] ) );
\6T_32x  (*
integer library_binding = "16nm";
 *)
ISRAM0 ( .B1( B1P1 ), 
.B0( B0P1 ), .A( A[31:0] ) );
 
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M1 ( B0P1, B0, net67, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M0 ( net67, S[0], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M3 ( net66, S[0], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M10 ( B1P2, B1, net65, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M9 ( net65, S[1], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M6 ( net64, S[1], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M7 ( B0P2, B0, net64, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M13 ( B0P3, B0, net63, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M12 ( net63, S[2], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M15 ( net62, S[2], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M16 ( B1P3, B1, net62, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M22 ( B1P4, B1, net61, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M21 ( net61, S[3], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M18 ( net60, S[3], cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M19 ( B0P4, B0, net60, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M4 ( B1P1, B1, net66, cds_globals.\gnd!  );
 
\6T_32x_CTRL  (*
integer library_binding = "16nm";
 *)
I4 ( .B1( B1P1 ), 
.B0( B0P1 ), .W1( W1 ), .W0( W0 ), .S( S[0] ) );
\6T_32x_CTRL  (*
integer library_binding = "16nm";
 *)
I11 ( .B1( B1P2 ), 
.B0( B0P2 ), .W1( W1 ), .W0( W0 ), .S( S[1] ) );
\6T_32x_CTRL  (*
integer library_binding = "16nm";
 *)
I20 ( .B1( B1P3 ), 
.B0( B0P3 ), .W1( W1 ), .W0( W0 ), .S( S[2] ) );
\6T_32x_CTRL  (*
integer library_binding = "16nm";
 *)
I27 ( .B1( B1P4 ), 
.B0( B0P4 ), .W1( W1 ), .W0( W0 ), .S( S[3] ) );
 
nand4_1x (*
integer library_binding = "16nm";
 *)
I16 ( .Y( SM1 ), .A( 
B1P1 ), .B( B1P2 ), .C( B1P3 ), .D( B1P4 ) );
nand4_1x (*
integer library_binding = "16nm";
 *)
I13 ( .Y( SM0 ), .A( 
B0P1 ), .B( B0P2 ), .C( B0P3 ), .D( B0P4 ) );
 
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C7 ( .PLUS( B1P4 ), .MINUS( cds_globals.\gnd!  ) );
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C3 ( .PLUS( B1P2 ), .MINUS( cds_globals.\gnd!  ) );
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C5 ( .PLUS( B1P3 ), .MINUS( cds_globals.\gnd!  ) );
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C6 ( .PLUS( B0P4 ), .MINUS( cds_globals.\gnd!  ) );
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C4 ( .PLUS( B0P3 ), .MINUS( cds_globals.\gnd!  ) );
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C2 ( .PLUS( B0P2 ), .MINUS( cds_globals.\gnd!  ) );
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C1 ( .PLUS( B1P1 ), .MINUS( cds_globals.\gnd!  ) );
cap #(.c(1.2822f)) (*
integer library_binding = "UCD_Analog_Parts";

 *)
C0 ( .PLUS( B0P1 ), .MINUS( cds_globals.\gnd!  ) );
 
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M5 ( B1P1, S[0], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M2 ( B0P1, S[0], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M11 ( B1P2, S[1], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M8 ( B0P2, S[1], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M17 ( B1P3, S[2], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M14 ( B0P3, S[2], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M20 ( B0P4, S[3], cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M23 ( B1P4, S[3], cds_globals.\vdd! , cds_globals.\vdd!  );

endmodule

// 
// Design File for: (16nm 6T_32x schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module \6T_32x  ( B0,B1,A ); 

inout   B0;
inout   B1;
inout [31:0]  A;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
 
\6T_4x  (*
integer library_binding = "16nm";
 *)
I7 ( .B1( B1 ), .B0( 
B0 ), .A( A[3:0] ) );
\6T_4x  (*
integer library_binding = "16nm";
 *)
I6 ( .B1( B1 ), .B0( 
B0 ), .A( A[7:4] ) );
\6T_4x  (*
integer library_binding = "16nm";
 *)
I5 ( .B1( B1 ), .B0( 
B0 ), .A( A[11:8] ) );
\6T_4x  (*
integer library_binding = "16nm";
 *)
I4 ( .B1( B1 ), .B0( 
B0 ), .A( A[15:12] ) );
\6T_4x  (*
integer library_binding = "16nm";
 *)
I3 ( .B1( B1 ), .B0( 
B0 ), .A( A[19:16] ) );
\6T_4x  (*
integer library_binding = "16nm";
 *)
I2 ( .B1( B1 ), .B0( 
B0 ), .A( A[23:20] ) );
\6T_4x  (*
integer library_binding = "16nm";
 *)
I1 ( .B1( B1 ), .B0( 
B0 ), .A( A[27:24] ) );
\6T_4x  (*
integer library_binding = "16nm";
 *)
I0 ( .B1( B1 ), .B0( 
B0 ), .A( A[31:28] ) );

endmodule

// 
// Design File for: (16nm 6T_4x schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module \6T_4x  ( A,B0,B1 ); 

inout [3:0]  A;
inout   B0;
inout   B1;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
 
\6T  (*
integer library_binding = "16nm";
 *)
I3 ( .B1( B1 ), .B0( B0 ), 
.A( A[0] ) );
\6T  (*
integer library_binding = "16nm";
 *)
I2 ( .B1( B1 ), .B0( B0 ), 
.A( A[1] ) );
\6T  (*
integer library_binding = "16nm";
 *)
I1 ( .B1( B1 ), .B0( B0 ), 
.A( A[2] ) );
\6T  (*
integer library_binding = "16nm";
 *)
I0 ( .B1( B1 ), .B0( B0 ), 
.A( A[3] ) );

endmodule

// 
// Design File for: (16nm 6T schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module \6T  ( A,B0,B1 ); 

inout   A;
inout   B0;
inout   B1;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M5 ( Q0, Q1, cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M4 ( Q1, Q0, cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(120n), .nfin(2), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M1 ( Q1, A, B1, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(120n), .nfin(2), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M0 ( Q0, A, B0, cds_globals.\gnd!  );
 
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M3 ( Q0, Q1, cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M2 ( Q1, Q0, cds_globals.\vdd! , cds_globals.\vdd!  );

endmodule

// 
// Design File for: (16nm 6T_32x_CTRL schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module \6T_32x_CTRL  ( B0,B1,S,W0,W1 ); 

inout   B0;
inout   B1;
input   S;
inout   W0;
inout   W1;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
 
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M10 ( B1, B0, net22, cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M9 ( net22, W1, cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M8 ( B0, B1, net23, cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M7 ( net23, W0, cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M2 ( B1, S, cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M0 ( B0, S, cds_globals.\vdd! , cds_globals.\vdd!  );
 
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M6 ( B1, W1, net24, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M5 ( net24, S, cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M4 ( net25, S, cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M3 ( B0, W0, net25, cds_globals.\gnd!  );

endmodule

// 
// Design File for: (16nm nand4_1x schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module nand4_1x ( Y,A,B,C,D ); 

output   Y;
input   A;
input   B;
input   C;
input   D;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
 
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M5 ( Y, D, cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M4 ( Y, C, cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M1 ( Y, B, cds_globals.\vdd! , cds_globals.\vdd!  );
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M0 ( Y, A, cds_globals.\vdd! , cds_globals.\vdd!  );
 
nfet #(.m(1), .nf(1), .w(240n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M7 ( net23, D, cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(240n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M6 ( net25, C, net23, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(240n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M3 ( net24, B, net25, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(240n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M2 ( Y, A, net24, cds_globals.\gnd!  );

endmodule

// 
// Design File for: (16nm 6T_SetRead schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module \6T_SetRead  ( \~R0 ,\~R1 ,Go,SM0,SM1 ); 

output   \~R0 ;
output   \~R1 ;
input   Go;
input [1:0]  SM0;

input [1:0]  SM1;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
 
nfet #(.m(1), .nf(1), .w(40n), .nfin(1), .l(16n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M6 ( net18, Go, cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(40n), .nfin(1), .l(16n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M5 ( \~R0 , SM0[0], net18, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(40n), .nfin(1), .l(16n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M3 ( \~R0 , SM0[1], net18, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(40n), .nfin(1), .l(16n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M2 ( net12, Go, cds_globals.\gnd! , cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(40n), .nfin(1), .l(16n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M1 ( \~R1 , SM1[1], net12, cds_globals.\gnd!  );
nfet #(.m(1), .nf(1), .w(40n), .nfin(1), .l(16n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M0 ( \~R1 , SM1[0], net12, cds_globals.\gnd!  );

endmodule

// 
// Design File for: (16nm inv_1x schematic)
//
// Verilog-AMS netlist generated by the AMS netlister, version  IC6.1.6.500.10 .
// Cadence Design Systems, Inc.

`include "disciplines.vams"
`include "userDisciplines.vams"
 
(* cds_ams_schematic *)
module inv_1x ( Y,A ); 

output   Y;
input   A;

 
parameter wp_grid=0;
parameter MinW="";
parameter pDLEcell="";
parameter \ln ="";
parameter MinL="";
parameter lp_grid=0;
parameter ModelType="system";
parameter lp="";
parameter wn="";
parameter wp="";
parameter pModel="pmos";
parameter ln_grid=0;
parameter nModel="nmos";
parameter wp_microns="";
parameter nDLEcell="";
parameter wn_microns="";
parameter bn="gnd!";
parameter wn_grid=0;
parameter bp="vdd!";
 
 
nfet #(.m(1), .nf(1), .w(60n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M0 ( Y, A, cds_globals.\gnd! , cds_globals.\gnd!  );
 
pfet #(.m(1), .nf(1), .w(100n), .nfin(1), .l(20n)) (*
integer 
library_binding = "NCSU_TechLib_FreePDK15";
integer passed_mfactor
 = "m";
 *)
M1 ( Y, A, cds_globals.\vdd! , cds_globals.\vdd!  );

endmodule

// 
// Design File for: (basic cds_alias functional)
//
// Verilog HDL for "basic", "cds_alias" "functional"

module cds_alias(a,a);
  parameter width = 1;
  inout [width-1:0] a;
endmodule

// 
// Design File for: (connectLib L2E_2 module)
//
// L2E_2.vams - Efficient logic-to-electrical connection module
// last revised:  7/19/12, jhou
//
// REVISION HISTORY:
// Created:  1/15/04 jhou
// Updated:  1/25/06 jhou - changed default tr to 0.2n
//           4/18/06 jhou - map digital X/Z to analog 0 by default
//                          in the full fast connect modules
// Updated:  7/19/12 jhou - enhanced for strength models under -amssie.

/****************************************************************************
Description:

* In 12.2, the connectmodule is enhanced for strength-based interface element
 (SIE), which supports strength-based models including tran gate, and it is
 enabled under -amssie option.
 The signal value and propagation at the analog-digital interface are
 resolved automatically based on the signal values and strengthes from
 drivers on both analog and digital sides.

* Compared to L2E, this L2E_2 logic-to-electrical connect module is designed
 for better simulation performance while having full support of unidirectional
 4-level (0, 1, X, and Z) logic to electrical value conversion, with
 the following different properties:

1, For digital side driver-receiver segregation, L2E_2 performs a direct
   mapping from ordinary module drivers to ordinary module receivers
   without considering analog loading effect feedback, since it is
   unidirectional at the digital to analog boundary.
   On connections where analog loading effects need to be considered
   in the digital reciver side, the ports in ordinary modules need to be
   declared as inout so that Bidir_2 modules are used for the same.

2, Analog voltages of vx/vz, mapped from digital X/Z, are defaulted to
   vlo (which is 0 by default) with output impedance rx/rz.
   When the digital input changes from any value to Z at time > 0,
   the analog output voltage does not change but only the output
   impedance changes to rz (which is high impedance by default).
   In contrast, L2E maps digital Z/X to analog vsup/2 by default, which
   is a worst case analysis but does not cover all worst cases.

3, The output resistance upon digital X, rx, is default to 10 times the
   sum of output-low and output-high resistances, since the output
   resistance of a gate during transition is usually higher.

4, When digital input changes, both analog output voltage and resistance
   transition linearly. This usually improves the convergence of
   simulation.

5, A 10% of rise/fall time tolerance is added on transition filters for
   better performance, but the time tolerance is applied only 
   when strictly following the rise/fall time would significantly
   reduce the simulation speed.

****************************************************************************/

`include "disciplines.vams"
`timescale 1ns / 1ps

//strength values
`define SUPPLY 7
`define STRONG 6
`define PULL   5
`define LARGE  4
`define WEAK   3
`define MEDIUM 2
`define SMALL  1
`define HIZ    0

connectmodule L2E_2(Din,Aout);
 input Din; \logic Din;         // digital input signal
 output Aout; electrical Aout;  // analog output signal
 
 parameter real vsup=1.8          from (0:inf);      // nominal supply voltage
 parameter real vlo=0             ;  // logic low voltage
 parameter real vhi=vlo+vsup      from (vlo:vlo+vsup];   // logic high voltage
 parameter real vthi=vsup/1.5     from (vlo:vhi);   // upper threshold
 parameter real vtlo=vsup/3       from (vlo:vthi);   // lower threshold
 parameter real vx=vlo            from [vlo:vhi];    // X output voltage
 parameter real tr=0.2n           from (0:inf);  // risetime of analog output
 parameter real tf=tr             from (0:inf);  // falltime of analog output
 parameter real ttol_t=(tr+tf)/20 from (0:inf);  // time tol of transition
 parameter real tdelay=0          from [0:inf);  // delay time of analog output
 parameter real rhi=200           from (0:inf);      // output resistance
 parameter real rlo=rhi           from (0:inf);      // output resistance
 parameter real rz=10M            from (0:inf);      // output resistance
 parameter real rx=10*(rlo+rhi)   from (0:inf);      // output resistance
 //Digital driver output resistence converted from strength
 parameter real  r_SUPPLY=4      from (0: 10k);
 parameter real  r_STRONG=(rhi+rlo)/2    from (0: inf);
 parameter real  r_PULL  =1.5e3  from (0: inf);
 parameter real  r_LARGE =9.0e3  from (r_PULL: inf);
 parameter real  r_WEAK  =5.5e4  from (r_LARGE: inf);
 parameter real  r_MEDIUM=3.2e5  from (r_WEAK: inf);
 parameter real  r_SMALL =1.9e6  from (r_MEDIUM: inf);
 //Analog driver output resistence up_threshold for converting to strength
 parameter real  rth_SUPPLY=sqrt(r_SUPPLY*r_STRONG);
 parameter real  rth_STRONG=sqrt(r_STRONG*r_PULL);
 parameter real  rth_PULL  =sqrt(r_PULL*r_LARGE);
 parameter real  rth_LARGE =sqrt(r_LARGE*r_WEAK);
 parameter real  rth_WEAK  =sqrt(r_WEAK*r_MEDIUM);

 real Vstate,Rout;              // output voltage & resistance states
 real rout;                     // analog output resistance

//STRENGTH RELATED VARIABLES:
 reg sie;
 integer zero_strength, one_strength;
 integer d_strength;
 reg  [1:0] d_logic;
 wire [31:0] Dval;
 
//============================================================================
 initial begin
   Vstate=vlo; Rout=rz;         // initially map digital default to vlo/rz
   $SIE_input(Din, Dval);       // set digital driver sensitivity
   sie = $strength_resolution(Din);
 end

// Calculate value from digital drivers in DRS (non-SIE) mode
 assign Din = sie? 1'bz : Din;  // direct driver-receiver propagation
 always if (!sie) begin
   case(Din)
     1'b0:  begin  Vstate=vlo; Rout=rlo;    end
     1'b1:  begin  Vstate=vhi; Rout=rhi;    end
     1'bz:  begin  Rout=rz;  end
     default:  begin Vstate=vx; Rout=rx;  end
   endcase
   @(Din); 
 end else @(sie);

// Calculate value and strength from digital drivers in SIE mode
 always if (sie) begin
   d_logic = Dval & 2'b11;
   zero_strength = (Dval >> 5) & 3'b111;
   one_strength = (Dval >> 2) & 3'b111;
   case (d_logic)
     2'b00: begin Vstate=vlo; Rout=rlo; d_strength = zero_strength; end
     2'b01: begin Vstate=vhi; Rout=rhi; d_strength = zero_strength; end
     2'b10: begin d_strength = `HIZ; end
     2'b11: begin Vstate=vx;  Rout=rx;  d_strength =     // for X, use smaller strength
          (zero_strength < one_strength) ? zero_strength : one_strength;
        end
     default: begin d_strength = `HIZ; end
   endcase
   //Convert strength to digital driver output resistance:
   case (d_strength)
    `SUPPLY : Rout = r_SUPPLY;
    `PULL   : Rout = r_PULL;
    `LARGE  : Rout = r_LARGE;
    `WEAK   : Rout = r_WEAK;
    `MEDIUM : Rout = r_MEDIUM;
    `SMALL  : Rout = r_SMALL;
    `HIZ    : Rout = rz;
   endcase
 @(Dval); end else @(sie);

 analog begin
  rout = transition(Rout,tdelay,tr,tf,ttol_t);     // rout shifts linearly also;
  I(Aout) <+ (V(Aout)-transition(Vstate,tdelay,tr,tf,ttol_t))/rout; 
 end
endmodule

// 
// Design File for: (connectLib E2L_2 module)
//
// E2L_2.vams - basic Verilog-AMS elect to logic connection module
// last revised:  7/19/12, jhou
//
// REVISION HISTORY:
// Created:  1/18/04 jhou
// Updated:  1/25/06 jhou - changed default tr to 0.2n
// Updated:  7/19/12 jhou - enhanced for strength models under -amssie.

/****************************************************************************
Description:

This electrical-to-logic connect module is designed for better simulation
performance. It supports 4-level logic (0, 1, X, and Z), and has
the following different properties compared to connectmodule E2L:

1, The optimized hysteresis setup between above functions maximizes the
   noise filtering capabilities and hence simulation speed. By default,
   the time tolerance in cross function is 1/4 of transition rise/fall
   time and voltage tolerance is 1/12 of voltage supply.

****************************************************************************/

`include "disciplines.vams"
`timescale 1ns / 1ps

//============================================================================
connectmodule E2L_2 (Ain, Dout);
  input Ain; electrical Ain;                     // electrical input
  output Dout; \logic Dout;                      // logic output

// INSTANCE PARAMETERS:
  parameter real vsup=1.8       from (0:inf);    // nominal supply voltage
  parameter real vthi=vsup/1.5  from (-inf:inf);          // upper threshold
  parameter real vtlo=vsup/3    from (-inf:vthi];          // lower threshold
  parameter real vtol=vsup/12   from (0:(vthi-vtlo)/2]; // voltage tolerance
  parameter real tr=0.2n        from (0:1m];     // risetime (for defaults)
  parameter real txdel=4*tr     from (0:1m];     // time midrange til output X
  parameter real ttol_c=tr/4    from (0:1m];     // time tolerance of crossing
  parameter real vtlox=vtlo+vtol   from (vtlo:vthi);  // lo-to-x threshold point
  parameter real vthix=vthi-vtol   from [vtlox:vthi); // hi-to-x threshold point

// LOCAL VARIABLES:
  reg Dreg;                // output register
  reg Xin;                 // flag if analog is in midrange
  real txdig;              // delay from midlevel to X in timescale units
  wire [31:0] Dval;
  reg sie;
  
//============================================================================
  initial begin
    txdig=txdel/1n;        // digital delay midlevel to X  (ASSUMES TIMESCALE)
    Dreg=1'b0;             // initial level
    Xin=0;                 // initially not in X delay region.
    $SIE_input(Dout, Dval);   //set digital driver sensitivity
    sie = $strength_resolution(Dout);
  end
// Convert analog signal to high/low and X/notX:
  always @(above(V(Ain)-vthi,ttol_c,vtol))
      begin Dreg=1; Xin=0; disable GoToX; end    // analog XtoH
  always @(above(vtlo-V(Ain),ttol_c,vtol))
      begin Dreg=0; Xin=0; disable GoToX; end    // analog XtoL
  always @(above(vthix-V(Ain),ttol_c,vtol))
      if (Dreg==1'b1) Xin=1;                     // analog HtoX
  always @(above(V(Ain)-vtlox,ttol_c,vtol))
      if (Dreg==1'b0) Xin=1;                     // analog LtoX
// Wait for txdel before driving output to X:
  always @(posedge(Xin)) begin :GoToX            // input changed to X
    #(txdig)                                     // wait for X time delay
    if (Xin==1) Dreg=1'bx;                       // goto X if still between
  end
  assign  Dout=Dreg;                             // assign register to output
endmodule

// 
// Design File for: (connectLib Bidir_2 module)
//
// Bidir_2.vams - Efficient bi-directional connection module
// last revised:  7/19/12, jhou
//
// REVISION HISTORY:
// Created:  1/18/04 jhou
// Updated:  1/25/06 jhou - changed default tr to 0.2n
//           4/18/06 jhou - map digital X/Z to analog 0 by default
//                          in the full fast connect modules
// Updated:  7/19/12 jhou - enhanced for strength models under -amssie.

/****************************************************************************
Description:

* In 12.2, the connectmodule is enhanced for strength-based interface element
 (SIE), which supports strength-based models including tran gate, and it is
 enabled under -amssie option.
 The signal value and propagation at the analog-digital interface are
 resolved automatically based on the signal values and strengthes from
 drivers on both analog and digital sides. 

* Compared to Bidir, this Bidir_2 bi-directional connect module is designed
 for better simulation performance while maintaining similar accuracy, with
 the following different properties:

1, Analog voltages of vx/vz, mapped from digital X/Z, are defaulted to
   vlo (which is 0 by default) with output impedance rx/rz.
   When the digital input changes from any value to Z at time > 0,
   the analog output voltage does not change but only the output
   impedance changes to rz (which is high impedance by default).
   In contrast, Bidir maps digital Z/X to analog vsup/2 by default, which
   is a worst case analysis but does not cover all worst cases.

2, The output resistance upon digital X, rx, is default to 10 times the
   sum of output-low and output-high resistances, since the output
   resistance of a gate during transition is usually higher.

3, When digital input changes, both analog output voltage and resistance
   transition linearly. This usually improves the convergence of 
   simulation.

4, A 10% of rise/fall time tolerance is added on transition filters for
   better performance, but the time tolerance is applied only 
   when strictly following the rise/fall time would significantly
   reduce the simulation speed.

5, Bidir_2 applies driver-receiver segregation on all digital signal levels, 
   while in contrast Bidir immediately feeds forward X value from
   driver to receiver.

6, The optimized hysteresis setup between above functions maximizes the
   noise filtering capabilities and hence simulation speed. By default,
   the time tolerance in cross function is 1/4 of transition rise/fall
   time and voltage tolerance is 1/12 of voltage supply.

****************************************************************************/

`include "disciplines.vams"
`timescale 1ns / 1ps

//strength values
`define SUPPLY 7
`define STRONG 6
`define PULL   5
`define LARGE  4
`define WEAK   3
`define MEDIUM 2
`define SMALL  1
`define HIZ    0

//============================================================================
connectmodule Bidir_2 (Din, Aout);
  inout Din; \logic Din;                      // logic signal
  inout Aout; electrical Aout;                // electrical signal

// INSTANCE PARAMETERS:
 parameter real vsup=1.8          from (0:inf);      // nominal supply voltage
 parameter real vlo=0             ;  // logic low voltage
 parameter real vhi=vlo+vsup          from (vlo:vlo+vsup];   // logic high voltage
 parameter real vthi=vsup/1.5     from (vlo:vhi);   // upper threshold
 parameter real vtlo=vthi/2       from (vlo:vthi);   // lower threshold
 parameter real vx=vlo            from [vlo:vhi];    // X output voltage
 parameter real tr=0.2n           from (0:inf);  // risetime of analog output
 parameter real tf=tr             from (0:inf);  // falltime of analog output
 parameter real ttol_t=(tr+tf)/20 from (0:inf);  // time tol of transition
 parameter real tdelay=0          from [0:inf);  // delay time of analog output
 parameter real rhi=200           from (0:inf);      // output resistance
 parameter real rlo=rhi           from (0:inf);      // output resistance
 parameter real rz=10M            from (0:inf);      // output resistance
 parameter real rx=10*(rlo+rhi)   from (0:inf);      // output resistance
 parameter real txdel=4*tr     from (0:1m];     // time midrange til output X
 parameter real ttol_c=tr/4    from (0:1m];     // time tolerance of crossing
 parameter real vtol=vsup/12   from (0:(vthi-vtlo)/2]; // voltage tolerance
 parameter real vtlox=vtlo+vtol   from (vtlo:vthi);  // lo-to-x threshold point
 parameter real vthix=vthi-vtol   from [vtlox:vthi); // hi-to-x threshold point
 //Digital driver output resistence converted from strength
 parameter real  r_SUPPLY=4      from (0: 10k);
 parameter real  r_STRONG=(rhi+rlo)/2    from (0: inf);
 parameter real  r_PULL  =1.5e3  from (0: inf);
 parameter real  r_LARGE =9.0e3  from (r_PULL: inf);
 parameter real  r_WEAK  =5.5e4  from (r_LARGE: inf);
 parameter real  r_MEDIUM=3.2e5  from (r_WEAK: inf);
 parameter real  r_SMALL =1.9e6  from (r_MEDIUM: inf);
 //Analog driver output resistence up_threshold for converting to strength
 parameter real  rth_SUPPLY=sqrt(r_SUPPLY*r_STRONG);
 parameter real  rth_STRONG=sqrt(r_STRONG*r_PULL);  
 parameter real  rth_PULL  =sqrt(r_PULL*r_LARGE);   
 parameter real  rth_LARGE =sqrt(r_LARGE*r_WEAK);   
 parameter real  rth_WEAK  =sqrt(r_WEAK*r_MEDIUM);  

// LOCAL VARIABLES:
 reg Dreg;                // register to write back logic
 real Vstate,Rout;        // output voltage & resistance states
 real rout;               // analog output resistance
 reg Xin;                 // flag if analog is in midrange
 real txdig;              // delay from midlevel to X in timescale units

//STRENGTH RELATED VARIABLES:
 real Ra;                 // state of analog driver output resistance
 real Rth;                // R threshold for converting to strength
 wire [7:0] strength_select; // flag to hold analog state
 reg sie;
 integer zero_strength, one_strength;
 integer d_strength;
 integer a_strength;
 reg  [1:0] d_logic;
 wire [31:0] Dval;
 real ra;               // analog driver output resistance

//============================================================================
  initial begin
    txdig=txdel/1n;        // digital delay midlevel to X  (ASSUMES TIMESCALE)
    Dreg=1'b0;             // initial level
    Xin=0;                 // initially not in X delay region.
    Vstate=vlo; Rout=rz;         // initially map digital default to vlo/rz
    Rth=rth_SUPPLY;        // initial R threshold.
    a_strength = `STRONG;    // default analog strength
    $SIE_input(Din, Dval);   //set digital driver sensitivity
    sie = $strength_resolution(Din);
  end

// Calculate value from digital drivers in DRS (non-SIE) mode
 always if (!sie) begin
   case(Din)
     1'b0:  begin  Vstate=vlo; Rout=rlo;    end
     1'b1:  begin  Vstate=vhi; Rout=rhi;    end
     1'bz:  begin  Rout=rz;  end
     default:  begin Vstate=vx; Rout=rx;  end
   endcase
   @(Din);
 end else @(sie);

// Calculate value and strength from digital drivers in SIE mode
 always if (sie) begin
   d_logic = Dval & 2'b11;
   zero_strength = (Dval >> 5) & 3'b111;
   one_strength = (Dval >> 2) & 3'b111;
   case (d_logic)
     2'b00: begin Vstate=vlo; Rout=rlo; d_strength = zero_strength; end
     2'b01: begin Vstate=vhi; Rout=rhi; d_strength = zero_strength; end
     2'b10: begin d_strength = `HIZ; end
     2'b11: begin Vstate=vx;  Rout=rx;  d_strength =     // for X, use smaller strength
          (zero_strength < one_strength) ? zero_strength : one_strength;
        end
     default: begin d_strength = `HIZ; end
   endcase
   //Convert strength to digital driver output resistance:
   case (d_strength)
    `SUPPLY : Rout = r_SUPPLY;
    `PULL   : Rout = r_PULL;
    `LARGE  : Rout = r_LARGE;
    `WEAK   : Rout = r_WEAK;
    `MEDIUM : Rout = r_MEDIUM;
    `SMALL  : Rout = r_SMALL;
    `HIZ    : Rout = rz;
   endcase
   Ra = ra;
 @(Dval); end else @(sie);
 always @(Dreg & sie) Ra = ra;
 always @(Ra) begin
   if(Ra < rth_SUPPLY)      a_strength = `SUPPLY;
   else if(Ra < rth_STRONG) a_strength = `STRONG;
   else if(Ra < rth_PULL)   a_strength = `PULL;
   else if(Ra < rth_WEAK)   a_strength = `WEAK;
   else                     a_strength = `HIZ;
 end
 assign strength_select = a_strength == `SUPPLY ? 8'b10000000
                        : a_strength == `STRONG ? 8'b01000000
                        : a_strength == `PULL   ? 8'b00100000
                        : a_strength <= `WEAK   ? 8'b00001000
                        :                         8'b00000000;              
 bufif1 (supply1, supply0) BSU(Din,  Dreg, strength_select[7]);
 bufif1 (strong1, strong0) BST(Din,  Dreg, strength_select[6]);
 bufif1 (pull1, pull0)     BPU(Din,  Dreg, strength_select[5]);
 bufif1 (weak1, weak0)     BWE(Din,  Dreg, strength_select[3]);

 analog begin
  rout = transition(Rout,tdelay,tr,tf,ttol_t);     // rout shifts linearly also;
  I(Aout) <+ (V(Aout)-transition(Vstate,tdelay,tr,tf,ttol_t))/rout;
  ra = $input_resistance(Aout, Vstate, Rout, Rth);
 end

// Reflect actual levels on analog side back to digital side:
  always @(above(V(Aout)-vthi,ttol_c,vtol))
      begin Dreg=1; Xin=0; disable GoToX; end    // analog XtoH
  always @(above(vtlo-V(Aout),ttol_c,vtol))
      begin Dreg=0; Xin=0; disable GoToX; end    // analog XtoL
  always @(above(vthix-V(Aout),ttol_c,vtol))
      if (Dreg==1'b1) Xin=1;                     // analog HtoX
  always @(above(V(Aout)-vtlox,ttol_c,vtol))
      if (Dreg==1'b0) Xin=1;                     // analog LtoX
// Wait for txdel before driving output to X:
  always @(posedge(Xin)) begin :GoToX            // input changed to X
    #(txdig)                                     // wait for X time delay
    if (Xin==1) Dreg=1'bx;                       // goto X if still between
  end

endmodule

// 
// Design File for: (connectLib E2R module)
//
// E2R.vams - basic Verilog-AMS electrical to discrete wreal connection module
// last revised:  11/06/14, asadigh, zhipeng, jhou
//
// REVISION HISTORY:
// Created:  08/01/06, jhou
// Revised to support current mode:  04/24/14, zhipeng, jhou
// Enhanced input current accuracy:  11/03/14, asadigh, jhou
// Enhanced for wreal current mode:  11/06/14, asadigh, zhipeng, jhou

`include "disciplines.vams"
`timescale 1ns / 1ps

connectmodule E2R (Ain, Dout);
input Ain;
electrical Ain;    //input electrical
output Dout;
wreal Dout;        //output wreal
\logic Dout;       //discrete domain

  parameter real vss=0             from (-inf:inf); // Voltage of negative supply
  parameter real vsup=1.8          from (0:inf);    // Supply voltage based on vss
  parameter real vdelta=vsup/64    from (0:inf);    // voltage delta
  parameter real vtol=vdelta/4     from (0:vdelta); // voltage tolerance
  parameter real ttol=10p          from (0:1m];     // time tolerance
  parameter integer currentmode=0  from [0:1];      // 0: voltage, 1: current mode
  parameter real idelta=10u        from (0:inf);    // current delta
  parameter real itol=idelta/4     from (0:idelta); // current tolerance
  parameter real vbias=vsup/2      from (0:vsup);   // bias level for input load
  parameter real rin=200           from (0:inf);    // input resistance

  parameter real vdd=vss+vsup;               // internal parameter: vss+vsup
  parameter real vdd10=vdd+vsup*10;          // internal parameter: vdd+vsup*10
  parameter real vss10=vss-vsup*10;          // internal parameter: vss-vsup*10
  parameter integer voltagemode=1-currentmode; // internal parameter: not current
  real Dreg;                          //real register for A to D wreal conversion
  real VprevD;                        //voltage at previous delta-step
  real iAin;                          //analog input current
  reg sie;

//============================================================================
  initial begin
    sie = $strength_resolution(Dout);
    VprevD = vss;
  end

  assign Dout = Dreg;

  //discretize V(Ain) triggered by absdelta function
  always @(absdelta(V(Ain)*voltagemode, vdelta, ttol, vtol))
	Dreg = currentmode?iAin:V(Ain);

  always @(absdelta(iAin*currentmode, idelta, ttol, itol)) begin
        if ( V(Ain) > vdd10 && VprevD < vdd10 )
          $display("Warning: AMS IE %M at %g: I(Ain)=%g is causing V(Ain)=%g 10x vsup above vdd. Please check for any mismatch between the electrical circuit and the E2R settings.",
              $abstime, iAin, V(Ain));
        if ( V(Ain) < vss10 && VprevD > vss10 )
          $display("Warning: AMS IE %M at %g: I(Ain)=%g is causing V(Ain)=%g 10x vsup below vss. Please check the E2R load settings (vbias, rin)",
              $abstime, iAin, V(Ain));
	Dreg = currentmode?iAin:V(Ain);
	VprevD = V(Ain);
  end

  analog begin
    if (currentmode) begin // set up load for current E2R:
        iAin = (V(Ain)-vbias)/rin;
        I(Ain) <+ iAin;
    end
  end

endmodule


// 
// Design File for: (connectLib R2E_2 module)
//
// R2E_2.vams - Efficient Verilog-AMS discrete wreal to electrical connection module
//
// REVISION HISTORY:
// Created:  09/01/08, gangchen
// Revised to support current mode:  04/24/14, zhipeng, jhou
// Enhanced for wreal current mode: 11/3/14, asadigh, zhipeng, jhou

`include "disciplines.vams"
`timescale 1ns / 1ps
 
connectmodule R2E_2 (Din, Aout);
  input Din;
  wreal Din;		// input wreal
  \logic Din;
  output Aout;
  electrical Aout;	// output electrical

  parameter real vss=0             from (-inf:inf); // Voltage of negative supply
  parameter real vsup=1.8          from (0:inf);    // supply voltage based on vss
  parameter real vdelta=vsup/64    from (0:vsup];   // voltage delta
  parameter real vx=vss            from [0:vsup];   // X output voltage
  parameter real tr=10p            from (0:inf);    // risetime of analog output
  parameter real tf=tr             from (0:inf);    // falltime of analog output
  parameter real ttol_t=(tr+tf)/20 from (0:inf);    // time tol of transition
  parameter real tdelay=0          from [0:1m);     // delay time of analog output
  parameter real rout=200          from (0:inf);    // output resistance
  parameter real rx=rout           from (0:inf);    // X output resistance
  parameter real rz=10M            from (0:inf);    // Z output resistance
  parameter integer currentmode=0  from [0:1];      // 0: voltage, 1: current mode
  parameter real idelta=10u        from (0:inf);    // current delta
  parameter real ix=0              from [0:inf);    // X output current
  parameter real i0=0              from [0:inf);    // 0 output current
  parameter integer clamp=0        from [0:1];      // 0: disable, 1: enable clamp
  parameter real dvclamp=vsup/20   from (0:vsup/2); // clamp zoon from supply

  parameter real vdd=vss+vsup;               // internal parameter: vss+vsup
  parameter real vdd10=vdd+vsup*10;          // internal parameter: vdd+vsup*10
  parameter real vss10=vss-vsup*10;          // internal parameter: vss-vsup*10
  real RealN, Rstate;
  real RealA;                          //analog value converted from wreal
  real VprevA;                         //voltage at previous analog-step
  real Rout;                           //impedence converted from wreal driver

  reg sie;
  initial begin
    if (Din === `wrealXState)
      begin RealN = currentmode?ix:vx; Rstate = rx; end
    else if (Din === `wrealZState)
      begin RealN = currentmode?i0:vss; Rstate = rz; end
    else
      begin RealN = Din; Rstate = rout; end
    sie = $strength_resolution(Din);
  end

  always begin
    if (Din === `wrealXState)
      begin RealN = currentmode?ix:vx; Rstate = rx; end
    else if (Din === `wrealZState)
      begin
        Rstate = rz;            //in voltage mode, Z means float, so Rout is rz
        if (currentmode) RealN = i0;  //in current mode, Z means open circuit, so I=i0
      end
    else begin
      Rstate = rout;
      if (currentmode) begin
        if ( abs(Din-RealN) >= idelta) RealN = Din; end
      else
        if (abs(Din-RealN) >= vdelta) RealN = Din;
    end
    @(Din);
  end

  assign Din = sie? `wrealZState : Din;

  analog initial VprevA = vss;
  analog begin
    RealA = transition(RealN, tdelay, tr, tf, ttol_t);
    Rout = transition(Rstate, tdelay, tr, tf, ttol_t);
    if (currentmode) begin
      if (RealA > 0) begin
        if (clamp) begin
          if (V(Aout) > vdd - dvclamp) begin
            if (VprevA < vdd - dvclamp)
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being clamped near vdd. Please check for any mismatch between the electrical circuit and the R2E",
                $abstime, RealN, V(Aout));
            VprevA = V(Aout);
            RealA = RealA * (vdd - V(Aout)) / dvclamp;
          end
        end else begin
          if (V(Aout) > vdd10 ) begin
            if (VprevA < vdd10 )
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being 10x vsup above vdd. Please check for any mismatch between the electrical circuit and the R2E",
                $abstime, RealN, V(Aout));
            VprevA = V(Aout);
          end
        end
      end else begin
        if (clamp) begin
          if ( V(Aout) < vss + dvclamp ) begin
            if ( VprevA > vss + dvclamp )
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being clamped near vss. Please check for any mismatch between the electrical circuit and the R2E",
               $abstime, RealN, V(Aout));
            VprevA = V(Aout);
            RealA = RealA * (V(Aout) - vss) / dvclamp;
          end
        end else begin
          if ( V(Aout) < vss10 ) begin
            if ( VprevA > vss10 )
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being 10x vsup below vss. Please check for any mismatch between the electrical circuit and the R2E",
               $abstime, RealN, V(Aout));
            VprevA = V(Aout);
          end
        end
      end
      I(Aout) <+ -RealA + V(Aout)/rz;
    end else begin
      I(Aout) <+ (V(Aout) - RealA) / Rout;
    end
  end

endmodule

// 
// Design File for: (connectLib ER_bidir module)
//
// ER_bidir.vams - basic Verilog-AMS connection module for electrical
// and discrete wreal bidirectional conversion
// last revised:  11/3/14, asadigh, zhipeng, jhou
//
// REVISION HISTORY:
// Created:  08/29/06, jhou
// Enhanced for wreal current mode: 11/3/14, asadigh, zhipeng, jhou

`include "disciplines.vams"
`timescale 1ns / 1ps

connectmodule ER_bidir (Din, Aout);
inout Din;
wreal Din;         //inout wreal
\logic Din;        //discrete domain
inout Aout;
electrical Aout;   //inout electrical

  parameter real vss=0             from (-inf:inf); // Voltage of negative supply
  parameter real vsup=1.8          from (0:inf);    // supply voltage based on vss
  parameter real vdelta=vsup/64    from (0:vsup];   // voltage delta
  parameter real vx=vss            from [0:vsup];   // X output voltage
  parameter real vtol=vdelta/4     from (0:vdelta); // voltage tolerance
  parameter real ttol=10p          from (0:1m];     // time tolerance
  parameter real tr=10p            from (0:inf);    // risetime of analog output
  parameter real tf=tr             from (0:inf);    // falltime of analog output
  parameter real ttol_t=(tr+tf)/20 from (0:inf);    // time tol of transition
  parameter real tdelay=0          from [0:1m);     // delay time of analog output
  parameter real rout=200          from (0:inf);    // output resistance
  parameter real rx=rout           from (0:inf);    // X output resistance
  parameter real rz=10M            from (0:inf);    // Z output resistance
  parameter integer currentmode=0  from [0:1];      // 0: voltage, 1: current mode
  parameter real idelta=10u        from (0:inf);    // current delta
  parameter real itol=idelta/4     from (0:idelta); // current tolerance
  parameter real ix=0              from [0:inf);    // X output current
  parameter real i0=0              from [0:inf);    // 0 output current
  parameter integer clamp=0        from [0:1];      // 0: disable, 1: enable clamp
  parameter real dvclamp=vsup/20   from (0:vsup/2); // clamp zoon from supply
  parameter real vbias=vsup/2      from (0:vsup);   // bias level for input load
  parameter real rin=200           from (0:inf);    // input resistance

  parameter real vdd=vss+vsup;               // internal parameter: vss+vsup
  parameter real vdd10=vdd+vsup*10;          // internal parameter: vdd+vsup*10
  parameter real vss10=vss-vsup*10;          // internal parameter: vss-vsup*10
  parameter integer voltagemode=1-currentmode; // internal parameter: not current
  real Dreg;       //real register for A to D wreal conversion
  real RealN;      //real register for D wreal to A conversion
  real Rout;       //output resistance
  real VprevD;                         //Voltage at previous delta-step
  real RealA;
  real VprevA;                         //Voltage at previous analog-step

  integer D_count = 0;

  reg sie;

  wreal R_val;

  wreal D_val;

  initial begin
        RealN = 0;
        $input_real_value(Din, R_val);
        D_count = $driver_count(Din);
        Rout = rz;
        VprevD = vss;
        Dreg = `wrealZState;
        sie = $strength_resolution(Din);
  end

  assign D_val = sie?R_val:Din;

  always begin
      if (((sie && (D_val === `wrealZState || D_count == 1)))
          || (!sie && (D_val === `wrealZState || D_count == 0))) begin
          Rout = rz;
          if (currentmode) RealN = 0;
      end else if ( D_val === `wrealXState ) begin
          RealN = currentmode?ix:vx;
          Rout = rx;
      end else begin
          Rout = rout;
      	  //filter out digital noise within +/-vdelta
          if (currentmode) begin
              if ( abs(Din-RealN) >= idelta ) RealN = D_val; 
          end else begin
              if ( abs(D_val-RealN) >= vdelta ) RealN = D_val;
          end
      end
      @(D_val) ;
  end

  //discretize V(Aout) triggered by absdelta function
  always @(absdelta(V(Aout)*voltagemode, vdelta, ttol, vtol))
    if ( (sie && (D_val === `wrealZState || D_count == 1)) || !sie )
    	Dreg = currentmode? I(Aout) : V(Aout);
    else
        Dreg = `wrealZState;

  always @(absdelta(I(Aout)*currentmode, idelta, ttol, itol)) begin
    if ( (sie && (D_val === `wrealZState || D_count == 1)) || !sie ) begin
        if ( V(Aout) > vdd10 && VprevD < vdd10 )
          $display("Warning: AMS IE %M at %g: I(Aout)=%g is causing V(Aout)=%g 10x vsup above vdd. Please check for any mismatch between the electrical circuit and the E2R settings.",
              $abstime, I(Aout), V(Aout));
        if ( V(Aout) < vss10 && VprevD > vss10 )
          $display("Warning: AMS IE %M at %g: I(Aout)=%g is causing V(Aout)=%g 10x vsup below vss. Please check the E2R load settings (vbias, rin)",
              $abstime, I(Aout), V(Aout));
    	Dreg = currentmode? I(Aout) : V(Aout);
        VprevD = V(Aout);
    end else
        Dreg = `wrealZState;
  end

  assign Din = Dreg;

  analog initial VprevA = vss;
  analog begin
    RealA = transition(RealN, tdelay, tr, tf, ttol_t);
    if (currentmode) begin
      if ( abs(RealA) < itol ) begin // set up load for current E2R:
        I(Aout) <+ (V(Aout)-vbias)/rin;
      end else // do current R2E 
      if (RealA > 0) begin
        if (clamp) begin
          if (V(Aout) > vdd - dvclamp) begin
            if (VprevA < vdd - dvclamp)
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being clamped near vdd. Please check for any mismatch between the electrical circuit and the R2E",
                $abstime, RealN, V(Aout));
            VprevA = V(Aout);
            RealA = RealA * (vdd - V(Aout)) / dvclamp;
          end
        end else begin
          if (V(Aout) > vdd10 ) begin
            if (VprevA < vdd10 )
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being 10x vsup above vdd. Please check for any mismatch between the electrical circuit and the R2E",
                $abstime, RealN, V(Aout));
            VprevA = V(Aout);
          end
        end
        I(Aout) <+ -RealA + V(Aout)/rz;
      end else begin
        if (clamp) begin
          if ( V(Aout) < vss + dvclamp ) begin
            if ( VprevA > vss + dvclamp )
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being clamped near vss. Please check for any mismatch between the electrical circuit and the R2E",
               $abstime, RealN, V(Aout));
            VprevA = V(Aout);
            RealA = RealA * (V(Aout) - vss) / dvclamp;
          end
        end else begin
          if ( V(Aout) < vss10 ) begin
            if ( VprevA > vss10 )
              $display("Warning: AMS IE %M at %g: wreal Din=%g is causing V(Aout)=%g being 10x vsup below vss. Please check for any mismatch between the electrical circuit and the R2E",
               $abstime, RealN, V(Aout));
            VprevA = V(Aout);
          end
        end
        I(Aout) <+ -RealA + V(Aout)/rz;
      end
    end else begin
      I(Aout) <+ (V(Aout) - RealA) / Rout;
    end
  end

endmodule

// 
// Design File for: (connectLib R2L module)
//
// R2L.vams - Basic Real to Logic connection module
//
// REVISION HISTORY
// Created: 01/14/11, aspratt

`include "disciplines.vams"
`timescale 1ns / 1ps


connectmodule R2L(Rin, Lout);
   output Lout;
   input  Rin; wreal Rin;
   
   parameter real vsup = 1.8 from (0:inf);      // nominal supply voltage
   parameter real vlo = 0;                      // logic low voltage
   parameter real vhi = vlo+vsup from (vlo:vlo+vsup];   // logic high voltage
   parameter real vtlo = vsup / 3;              // lower threshold
   parameter real vthi = vsup /1.5;             // upper threshold
   
   reg 	     R_conv;
   
   initial
     begin
	/* set the initial value to Z */
        R_conv = 1'bz;
     end
   
   // Determine the value of R and convert to a logic value
   always
     begin
        if(Rin >= vthi)
	  R_conv = 1'b1;
        else if (Rin <= vtlo)
          R_conv = 1'b0;
        else if(Rin === `wrealZState)
          R_conv = 1'bz;
        else
          R_conv = 1'bx;

        @(Rin);
     end
   
   // drive the converted value back onto the output L pin
   assign Lout = R_conv;
   
   
endmodule

// 
// Design File for: (connectLib L2R module)
//
// L2R.vams - Basic Logic to Real connection module
//
// REVISION HISTORY
// Created: 01/14/11, aspratt

`include "disciplines.vams"
`timescale 1ns / 1ps


connectmodule L2R(Rout, Lin);
   input Lin;
   output  Rout; wreal Rout;
   
   parameter real vsup = 1.8 from (0:inf);  // nominal supply voltage
   parameter real vlo = 0;                  // logic low vlotage
   parameter real vhi = vlo+vsup from (vlo:vlo+vsup];   // logic high voltage

   real L_conv;

   initial
     begin
	/* set the initial value to Z */
        L_conv = `wrealZState;
     end
   
   // Determine the value of L and convert to a real value
   always
     begin
	case (Lin)
	  1'b0:
	    L_conv = vlo;
	  1'b1:
	    L_conv = vhi;
	  1'bz:
	    L_conv = `wrealZState;
	  1'bx:
	    L_conv = `wrealXState;
	  default:
	    L_conv = `wrealXState;
	endcase // case(L_code)
	
        @(Lin);
     end
   
   // drive the converted value back onto the output R pin
   assign Rout = L_conv;
   
endmodule

// 
// Design File for: (connectLib RL_bidir module)
//
// RL_bidir.vams - Basic Real to Logic bidirectional connection module
//
// REVISION HISTORY
// Created: 01/14/11, aspratt

`include "disciplines.vams"
`timescale 1ns / 1ps


connectmodule RL_bidir(R, L);
   inout L;
   inout  R; wreal R;
   
   parameter real vsup = 1.8 from (0:inf);      // nominal supply voltage
   parameter real vlo = 0;                      // logic low voltage
   parameter real vhi = vlo+vsup from (vlo:vlo+vsup];   // logic high voltage
   parameter real vtlo = vsup / 3;              // lower threshold
   parameter real vthi = vsup /1.5;             // upper threshold

   wreal       R_val;
   reg 	       R_conv;
   wire [1:0]  L_val;
   real        L_conv;

   initial
     begin
        $input_logic_value(L, L_val); // set logic driver sensativity
	$input_real_value(R, R_val);     // set real driver sensativity
	R_conv = 1'bz;
	L_conv = `wrealZState;
     end

    // Determine the value of R and convert to a logic value
   always
     begin
        if(R_val >= vthi)
	  R_conv = 1'b1;
        else if (R_val <= vtlo)
          R_conv = 1'b0;
        else if(R_val === `wrealZState)
          R_conv = 1'bz;
        else
          R_conv = 1'bx;

        @(R_val);
     end // always begin

   // Determine the value of L and convert to a real value
   always
     begin
	
	case (L_val)
	  2'b00:
	    L_conv = vlo;
	  2'b01:
	    L_conv = vhi;
	  2'b10:
	    L_conv = `wrealZState;
	  2'b11:
	    L_conv = `wrealXState;
	endcase // case(L_val)
	
        @(L_val);
     end // always begin


   // drive the converted value back onto the output R pin
   assign R = L_conv;
   
   // drive the converted value back onto the output L pin
   assign L = R_conv;
   
endmodule // R2L_bidir

// 
// Design File for: (connectLib L2E_2_LPS module)
//
// L2E_2.vams - Efficient logic-to-electrical connection module
// last revised:  04/18/06, jhou
//
// REVISION HISTORY:
// Created:  1/15/04 jhou
// Updated:  1/25/06 jhou - changed default tr to 0.2n
//           4/18/06 jhou - map digital X/Z to analog 0 by default
//                          in the full fast connect modules

// Created:  08/08 nzhang - this connect module is a copy from L2E_2.vams and
//                          specified for AMSLPS.
//                          * add parameter real vx_amslps_poweroff=0.2
//                          * add $amslps_power_initial()
//                                $amslps_get_power_state()
//                            func/task call to check the power status of
//                            the drivers of Din when Din is X, and change
//                            the output voltage if the driver is shutoff.
// Updated:  02/09 nzhang - update the connect module to support vpso in iecard
//                          * change the parameter vx_amslps_poweroff to vpso
// Updated:  03/09 nzhang - update the connect module to support power modes
//                          and nominal condition for AMSLPS
//                          * add parameter integer iecflag to mark the params
//                            which is set in iecard.
//                          * improve the features of $amslps_get_power_state(),
//                            and call this task when Din is 0/1/X.
//                            the task $amslps_get_power_state() will check the
//                            power status of the drivers of Din,
//                            and change the analog output voltage inside.
// Updated:  05/11 nzhang - update the connect module to trace power info on
//                          analog side
//                          * add $amslps_power_state_register(iPwrState, vPwrArgArray)
//
/****************************************************************************
Description:

This logic-to-electrical connect module, L2E_2, is designed for better
simulation performance while having full support of unidirectional 4-level
(0, 1, X, and Z) logic to electrical value conversion. It has
the following different properties compared to connectmodule L2E:

1, For digital side driver-receiver segregation, L2E_2 performs a direct
   mapping from ordinary module drivers to ordinary module receivers
   without considering analog loading effect feedback, since it is
   unidirectional at the digital to analog boundary.
   On connections where analog loading effects need to be considered
   in the digital reciver side, the ports in ordinary modules need to be
   declared as inout so that Bidir_2 modules are used for the same.

2, Analog voltages of vx/vz, mapped from digital X/Z, are defaulted to
   vlo (which is 0 by default) with output impedance rx/rz.
   When the digital input changes from any value to Z at time > 0,
   the analog output voltage does not change but only the output
   impedance changes to rz (which is high impedance by default).
   In contrast, L2E maps digital Z/X to analog vsup/2 by default, which
   is a worst case analysis but does not cover all worst cases.

3, The output resistance upon digital X, rx, is default to 10 times the
   sum of output-low and output-high resistances, since the output
   resistance of a gate during transition is usually higher.

4, When digital input changes, both analog output voltage and resistance
   transition linearly. This usually improves the convergence of
   simulation.

5, A 10% of rise/fall time tolerance is added on transition filters for
   better performance, but the time tolerance is applied only 
   when strictly following the rise/fall time would significantly
   reduce the simulation speed.

****************************************************************************/

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO     0
`define AMSLPS_NOMVDD   1
`define AMSLPS_NOMVSS   2
`define AMSLPS_NOMPMOS  3
`define AMSLPS_NOMNMOS  4
`define AMSLPS_ARGSIZE  4

//strength values
`define SUPPLY 7
`define STRONG 6
`define PULL   5
`define LARGE  4
`define WEAK   3
`define MEDIUM 2
`define SMALL  1
`define HIZ    0

connectmodule L2E_2_LPS(Din,Aout);
 input Din; \logic Din;         // digital input signal
 output Aout; electrical Aout;  // analog output signal
 
 parameter real vsup=1.8          from (0:inf);      // nominal supply voltage
 parameter real vlo=0             from (-inf:vsup);  // logic low voltage
 parameter real vhi=vsup          from (vlo:vsup];   // logic high voltage
 parameter real vthi=vsup/1.5     from (vlo:vsup];   // upper threshold
 parameter real vtlo=vsup/3       from (vlo:vsup];   // lower threshold
 parameter real vx=vlo            from [vlo:vhi];    // X output voltage
 parameter real tr=0.2n           from (0:inf);  // risetime of analog output
 parameter real tf=tr             from (0:inf);  // falltime of analog output
 parameter real ttol_t=(tr+tf)/20 from (0:inf);  // time tol of transition
 parameter real tdelay=0          from [0:inf);  // delay time of analog output
 parameter real rhi=200           from (0:inf);      // output resistance
 parameter real rlo=rhi           from (0:inf);      // output resistance
 parameter real rz=10M            from (0:inf);      // output resistance
 parameter real rx=10*(rlo+rhi)   from (0:inf);      // output resistance

 //Digital driver output resistence converted from strength
 parameter real  r_SUPPLY=4      from (0: 10k);
 parameter real  r_STRONG=(rhi+rlo)/2    from (0: inf);
 parameter real  r_PULL  =1.5e3  from (0: inf);
 parameter real  r_LARGE =9.0e3  from (r_PULL: inf);
 parameter real  r_WEAK  =5.5e4  from (r_LARGE: inf);
 parameter real  r_MEDIUM=3.2e5  from (r_WEAK: inf);
 parameter real  r_SMALL =1.9e6  from (r_MEDIUM: inf);
 //Analog driver output resistence up_threshold for converting to strength
 parameter real  rth_SUPPLY=sqrt(r_SUPPLY*r_STRONG);
 parameter real  rth_STRONG=sqrt(r_STRONG*r_PULL);
 parameter real  rth_PULL  =sqrt(r_PULL*r_LARGE);
 parameter real  rth_LARGE =sqrt(r_LARGE*r_WEAK);
 parameter real  rth_WEAK  =sqrt(r_WEAK*r_MEDIUM);

// INSTANCE PARAMETERS for AMSLPS:
  parameter real    vpso=0.2;   // X output voltage

 real Vstate,Rout;              // output voltage & resistance states
 real rout;                     // analog output resistance
 real vpxz;                     // nominal voltage in AMSLPS

 reg  iPwrState;                        // register the power state
 real vPwrArgArray[`AMSLPS_ARGSIZE:0];  // voltage value of the nominal condition

//STRENGTH RELATED VARIABLES:
 reg sie;
 integer zero_strength, one_strength;
 integer d_strength;
 reg  [1:0] d_logic;
 wire [31:0] Dval;
 
//============================================================================
 initial begin
    Vstate=vlo; Rout=rz;         // initially map digital default to vlo/rz
    $SIE_input(Din, Dval);       // set digital driver sensitivity
    sie = $strength_resolution(Din);
    // AMSLPS
    iPwrState = 1'b1;
    vPwrArgArray[`AMSLPS_VPSO]=vpso;
    vPwrArgArray[`AMSLPS_NOMVDD]=vhi;
    vPwrArgArray[`AMSLPS_NOMVSS]=vlo;
    $amslps_power_state_register(iPwrState, vPwrArgArray);
    vpxz = vPwrArgArray[`AMSLPS_NOMVSS];
 end

// Calculate value from digital drivers in DRS (non-SIE) mode
 assign Din = sie? 1'bz : Din;  // direct driver-receiver propagation
 always if (!sie) begin
   vpxz = vPwrArgArray[`AMSLPS_NOMVSS];  // recalculate working voltage
   case (Din)
     1'b0:  begin  Vstate=vPwrArgArray[`AMSLPS_NOMVSS]; Rout=rlo;    end
     1'b1:  begin  Vstate=vPwrArgArray[`AMSLPS_NOMVDD]; Rout=rhi;    end
     1'bz:  begin  Rout=rz;  end
     default:  begin 
            if (iPwrState==1'b0) Vstate=vPwrArgArray[`AMSLPS_VPSO];
            else                 Vstate=vpxz;
            Rout=rx;  end
   endcase
   @(Din or iPwrState); 
 end else @(sie);

// Calculate value and strength from digital drivers in SIE mode
 always if (sie) begin
   vpxz = vPwrArgArray[`AMSLPS_NOMVSS];  // recalculate working voltage
   d_logic = Dval & 2'b11;
   zero_strength = (Dval >> 5) & 3'b111;
   one_strength = (Dval >> 2) & 3'b111;
   case (d_logic)
     2'b00: begin Vstate=vPwrArgArray[`AMSLPS_NOMVSS]; Rout=rlo; d_strength = zero_strength; end
     2'b01: begin Vstate=vPwrArgArray[`AMSLPS_NOMVDD]; Rout=rhi; d_strength = zero_strength; end
     2'b10: begin d_strength = `HIZ; end
     2'b11: begin
            if (iPwrState==1'b0) Vstate=vPwrArgArray[`AMSLPS_VPSO];
            else                 Vstate=vpxz;
            Rout=rx;  d_strength =     // for X, use smaller strength
            (zero_strength < one_strength) ? zero_strength : one_strength;
        end
     default: begin d_strength = `HIZ; end
   endcase
   //Convert strength to digital driver output resistance:
   case (d_strength)
    `SUPPLY : Rout = r_SUPPLY;
    `PULL   : Rout = r_PULL;
    `LARGE  : Rout = r_LARGE;
    `WEAK   : Rout = r_WEAK;
    `MEDIUM : Rout = r_MEDIUM;
    `SMALL  : Rout = r_SMALL;
    `HIZ    : Rout = rz;
   endcase
   @(Dval or iPwrState); end else @(sie);

 analog begin
  rout = transition(Rout,tdelay,tr,tf,ttol_t);     // rout shifts linearly also;
  I(Aout) <+ (V(Aout)-transition(Vstate,tdelay,tr,tf,ttol_t))/rout; 
 end
endmodule

// 
// Design File for: (connectLib Bidir_2_LPS module)
//
// Bidir_2.vams - Efficient bi-directional connection module
// last revised:  04/18/06, jhou
//
// REVISION HISTORY:
// Created:  1/18/04 jhou
// Updated:  1/25/06 jhou - changed default tr to 0.2n
//           4/18/06 jhou - map digital X/Z to analog 0 by default
//                          in the full fast connect modules
// Created:  06/09 nzhang - this connect module is a copy from Bidir_2.vams and
//                          specified for AMSLPS.
//                          * add parameter real vpso=0.2
//                          * add $amslps_power_initial()
//                                $amslps_get_power_state()
//                            func/task call to check the power status of
//                            the drivers of Din, and change the output
//                            voltage if the driver is shutoff.
// Updated:  12/10 nzhang - update amscpf-vpi interface to handle power state
//                          on analog side
//
/****************************************************************************
Description:

This bi-directional connect module, Bidir_2, is designed for better simulation
performance while maintaining similar accuracy as that of Bidir. Bidir_2
has the following different properties compared to Bidir:

1, Analog voltages of vx/vz, mapped from digital X/Z, are defaulted to
   vlo (which is 0 by default) with output impedance rx/rz.
   When the digital input changes from any value to Z at time > 0,
   the analog output voltage does not change but only the output
   impedance changes to rz (which is high impedance by default).
   In contrast, Bidir maps digital Z/X to analog vsup/2 by default, which
   is a worst case analysis but does not cover all worst cases.

2, The output resistance upon digital X, rx, is default to 10 times the
   sum of output-low and output-high resistances, since the output
   resistance of a gate during transition is usually higher.

3, When digital input changes, both analog output voltage and resistance
   transition linearly. This usually improves the convergence of 
   simulation.

4, A 10% of rise/fall time tolerance is added on transition filters for
   better performance, but the time tolerance is applied only 
   when strictly following the rise/fall time would significantly
   reduce the simulation speed.

5, Bidir_2 applies driver-receiver segregation on all digital signal levels, 
   while in contrast Bidir immediately feeds forward X value from
   driver to receiver.

6, The optimized hysteresis setup between above functions maximizes the
   noise filtering capabilities and hence simulation speed. By default,
   the time tolerance in cross function is 1/4 of transition rise/fall
   time and voltage tolerance is 1/12 of voltage supply.

****************************************************************************/

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO     0
`define AMSLPS_NOMVDD   1
`define AMSLPS_NOMVSS   2
`define AMSLPS_NOMPMOS  3
`define AMSLPS_NOMNMOS  4
`define AMSLPS_ARGSIZE  4
`define AMSLPS_PWRSTATE_DIG 0
`define AMSLPS_PWRSTATE_ANA 1

//strength values
`define SUPPLY 7
`define STRONG 6
`define PULL   5
`define LARGE  4
`define WEAK   3
`define MEDIUM 2
`define SMALL  1
`define HIZ    0

//============================================================================
connectmodule Bidir_2_LPS (Din, Aout);
  inout Din; \logic Din;                      // logic signal
  inout Aout; electrical Aout;                // electrical signal

// INSTANCE PARAMETERS:
 parameter real vsup=1.8          from (0:inf);      // nominal supply voltage
 parameter real vlo=0             from (-inf:vsup);  // logic low voltage
 parameter real vhi=vsup          from (vlo:vsup];   // logic high voltage
 parameter real vthi=vsup/1.5     from (vlo:vsup];   // upper threshold
 parameter real vtlo=vthi/2       from (vlo:vsup];   // lower threshold
 parameter real vx=vlo            from [vlo:vhi];    // X output voltage
 parameter real tr=0.2n           from (0:inf);  // risetime of analog output
 parameter real tf=tr             from (0:inf);  // falltime of analog output
 parameter real ttol_t=(tr+tf)/20 from (0:inf);  // time tol of transition
 parameter real tdelay=0          from [0:inf);  // delay time of analog output
 parameter real rhi=200           from (0:inf);      // output resistance
 parameter real rlo=rhi           from (0:inf);      // output resistance
 parameter real rz=10M            from (0:inf);      // output resistance
 parameter real rx=10*(rlo+rhi)   from (0:inf);      // output resistance
 parameter real txdel=4*tr     from (0:1m];     // time midrange til output X
 parameter real ttol_c=tr/4    from (0:1m];     // time tolerance of crossing
 parameter real vtol=vsup/12   from (0:(vthi-vtlo)/2]; // voltage tolerance
 parameter real vtlox=vtlo+vtol   from (vtlo:vthi);  // lo-to-x threshold point
 parameter real vthix=vthi-vtol   from [vtlox:vthi); // hi-to-x threshold point
 //Digital driver output resistence converted from strength
 parameter real  r_SUPPLY=4      from (0: 10k);
 parameter real  r_STRONG=(rhi+rlo)/2    from (0: inf);
 parameter real  r_PULL  =1.5e3  from (0: inf);
 parameter real  r_LARGE =9.0e3  from (r_PULL: inf);
 parameter real  r_WEAK  =5.5e4  from (r_LARGE: inf);
 parameter real  r_MEDIUM=3.2e5  from (r_WEAK: inf);
 parameter real  r_SMALL =1.9e6  from (r_MEDIUM: inf);
 //Analog driver output resistence up_threshold for converting to strength
 parameter real  rth_SUPPLY=sqrt(r_SUPPLY*r_STRONG);
 parameter real  rth_STRONG=sqrt(r_STRONG*r_PULL);  
 parameter real  rth_PULL  =sqrt(r_PULL*r_LARGE);   
 parameter real  rth_LARGE =sqrt(r_LARGE*r_WEAK);   
 parameter real  rth_WEAK  =sqrt(r_WEAK*r_MEDIUM);  

// INSTANCE PARAMETERS for AMSLPS:
 parameter real    vpso=0.2;                 // X output voltage
  
// LOCAL VARIABLES:
 reg Dreg;                // register to write back logic
 real Vstate,Rout;        // output voltage & resistance states
 real rout;               // analog output resistance
 reg Xin;                 // flag if analog is in midrange
 real txdig;              // delay from midlevel to X in timescale units
 real vptol,vpxz;         // nominal voltage in AMSLPS
 real vpthi,vptlo;        // threshold voltage in AMSLPS
 real vpthix,vptlox;      // X state threshold voltage in AMSLPS

 reg  [1:0]iPwrState;                   // register the power state
 real vPwrArgArray[`AMSLPS_ARGSIZE:0];  // voltage value of the nominal condition

//STRENGTH RELATED VARIABLES:
 real Ra;                 // state of analog driver output resistance
 real Rth;                // R threshold for converting to strength
 wire [7:0] strength_select; // flag to hold analog state
 reg sie;
 integer zero_strength, one_strength;
 integer d_strength;
 integer a_strength;
 reg  [1:0] d_logic;
 wire [31:0] Dval;
 real ra;               // analog driver output resistance

//============================================================================
  initial begin
    txdig=txdel/1n;        // digital delay midlevel to X  (ASSUMES TIMESCALE)
    Dreg=1'b0;             // initial level
    Xin=0;                 // initially not in X delay region.
    Vstate=vlo; Rout=rz;         // initially map digital default to vlo/rz
    Rth=rth_SUPPLY;        // initial R threshold.
    a_strength = `STRONG;    // default analog strength
    $SIE_input(Din, Dval);   //set digital driver sensitivity
    sie = $strength_resolution(Din);
    // AMSLPS
    iPwrState = 2'b11;
    vPwrArgArray[`AMSLPS_VPSO]=vpso;
    vPwrArgArray[`AMSLPS_NOMVDD]=vhi;
    vPwrArgArray[`AMSLPS_NOMVSS]=vlo;
    $amslps_power_state_register(iPwrState, vPwrArgArray);
    vpthi=vPwrArgArray[`AMSLPS_NOMVDD]/1.5;
    vptlo=vPwrArgArray[`AMSLPS_NOMVDD]/3;
    vptol=vPwrArgArray[`AMSLPS_NOMVDD]/12;
    vpthix= vpthi-vptol;
    vptlox= vptlo+vptol;
    vpxz=vPwrArgArray[`AMSLPS_NOMVSS];
  end

// Calculate value from digital drivers in DRS (non-SIE) mode
 always if (!sie) begin
   // recalculate working voltage
   vpthi = vPwrArgArray[`AMSLPS_NOMVDD]/1.5;
   vptlo = vPwrArgArray[`AMSLPS_NOMVDD]/3;
   vptol = vPwrArgArray[`AMSLPS_NOMVDD]/12;
   vpthix= vpthi-vptol;
   vptlox= vptlo+vptol;
   vpxz  = vPwrArgArray[`AMSLPS_NOMVSS];
   case(Din)
     1'b0:  begin  Vstate=vPwrArgArray[`AMSLPS_NOMVSS]; Rout=rlo;
                   if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                   else if (V(Aout)>vpthi) Dreg=1'b1;
                   else if (V(Aout)<vptlo) Dreg=1'b0;
            end
     1'b1:  begin  Vstate=vPwrArgArray[`AMSLPS_NOMVDD]; Rout=rhi;
                   if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                   else if (V(Aout)>vpthi) Dreg=1'b1;
                   else if (V(Aout)<vptlo) Dreg=1'b0;
            end
     1'bz:    begin Rout=rz; 
                    if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                    else
                    Dreg=((V(Aout)>vpthi) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd1 :
                         ((V(Aout)<vptlo) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd0 : 1'dx;
              end
     default: begin
                    if (iPwrState[`AMSLPS_PWRSTATE_DIG]==1'b0) Vstate=vPwrArgArray[`AMSLPS_VPSO];
                    else                 Vstate=vpxz;
                    Rout=rx;
                    if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                    else
                    Dreg=((V(Aout)>vpthi) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd1 :
                         ((V(Aout)<vptlo) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd0 : 1'dx;
              end
   endcase
   @(Din or iPwrState);
 end else @(sie);

// Calculate value and strength from digital drivers in SIE mode
 always if (sie) begin
   // recalculate working voltage
   vpthi = vPwrArgArray[`AMSLPS_NOMVDD]/1.5;
   vptlo = vPwrArgArray[`AMSLPS_NOMVDD]/3;
   vptol = vPwrArgArray[`AMSLPS_NOMVDD]/12;
   vpthix= vpthi-vptol;
   vptlox= vptlo+vptol;
   vpxz  = vPwrArgArray[`AMSLPS_NOMVSS];

   d_logic = Dval & 2'b11;
   zero_strength = (Dval >> 5) & 3'b111;
   one_strength = (Dval >> 2) & 3'b111;
   case (d_logic)
     2'b00:  begin  Vstate=vPwrArgArray[`AMSLPS_NOMVSS]; Rout=rlo;
                   if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                   else if (V(Aout)>vpthi) Dreg=1'b1;
                   else if (V(Aout)<vptlo) Dreg=1'b0;
                   d_strength = zero_strength;
            end
     2'b01:  begin  Vstate=vPwrArgArray[`AMSLPS_NOMVDD]; Rout=rhi;
                   if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                   else if (V(Aout)>vpthi) Dreg=1'b1;
                   else if (V(Aout)<vptlo) Dreg=1'b0;
                   d_strength = zero_strength;
            end
     2'b11:  begin
                    if (iPwrState[`AMSLPS_PWRSTATE_DIG]==1'b0) Vstate=vPwrArgArray[`AMSLPS_VPSO];
                    else                 Vstate=vpxz;
                    Rout=rx;
                    if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                    else
                    Dreg=((V(Aout)>vpthi) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd1 :
                         ((V(Aout)<vptlo) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd0 : 1'dx;
                    Rout=rx;  d_strength =     // for X, use smaller strength
                    (zero_strength < one_strength) ? zero_strength : one_strength;
              end
     default:  begin Rout=rz; 
                    if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0) Dreg=1'bx;
                    else
                    Dreg=((V(Aout)>vpthi) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd1 :
                         ((V(Aout)<vptlo) && (iPwrState[`AMSLPS_PWRSTATE_DIG]!=1'b0))? 1'd0 : 1'dx;
                    d_strength = `HIZ;
              end
   endcase
   Ra = ra;
 @(Dval or iPwrState); end else @(sie);
 always @(Dreg & sie) Ra = ra;
 always @(Ra) begin
   if(Ra < rth_SUPPLY)      a_strength = `SUPPLY;
   else if(Ra < rth_STRONG) a_strength = `STRONG;
   else if(Ra < rth_PULL)   a_strength = `PULL;
   else if(Ra < rth_WEAK)   a_strength = `WEAK;
   else                     a_strength = `HIZ;
 end
 assign strength_select = a_strength == `SUPPLY ? 8'b10000000
                        : a_strength == `STRONG ? 8'b01000000
                        : a_strength == `PULL   ? 8'b00100000
                        : a_strength <= `WEAK   ? 8'b00001000
                        :                         8'b00000000;              
 bufif1 (supply1, supply0) BSU(Din,  Dreg, strength_select[7]);
 bufif1 (strong1, strong0) BST(Din,  Dreg, strength_select[6]);
 bufif1 (pull1, pull0)     BPU(Din,  Dreg, strength_select[5]);
 bufif1 (weak1, weak0)     BWE(Din,  Dreg, strength_select[3]);

 analog begin
  rout = transition(Rout,tdelay,tr,tf,ttol_t);     // rout shifts linearly also;
  I(Aout) <+ (V(Aout)-transition(Vstate,tdelay,tr,tf,ttol_t))/rout;
  ra = $input_resistance(Aout, Vstate, Rout, Rth);
 end

// Reflect actual levels on analog side back to digital side:
  always @(above(V(Aout)-vpthi,ttol_c,vptol)) begin
    // do not propagate analog value to digital scope if analog side is shutoff
    if (iPwrState[`AMSLPS_PWRSTATE_ANA]!==1'b0) begin
      if (iPwrState[`AMSLPS_PWRSTATE_DIG]!==1'b0) Dreg=1'b1;
      else if (Din===1'b1)  Dreg=1'b1;
      Xin=0; disable GoToX;
    end                                          // analog XtoH
  end
  always @(above(vptlo-V(Aout),ttol_c,vptol)) begin
    // do not propagate analog value to digital scope if analog side is shutoff
    if (iPwrState[`AMSLPS_PWRSTATE_ANA]!==1'b0) begin
      if (iPwrState[`AMSLPS_PWRSTATE_DIG]!==1'b0) Dreg=1'b0;
      else if (Din===1'b0)  Dreg=1'b0;
      Xin=0; disable GoToX;
    end                                          // analog XtoL
  end
  always @(above(vpthix-V(Aout),ttol_c,vptol)) begin
    // do not propagate analog value to digital scope if analog side is shutoff
    if (iPwrState[`AMSLPS_PWRSTATE_ANA]!==1'b0) begin
      if (Dreg==1'b1) Xin=1;                     // analog HtoX
    end
  end
  always @(above(V(Aout)-vptlox,ttol_c,vptol)) begin
    // do not propagate analog value to digital scope if analog side is shutoff
    if (iPwrState[`AMSLPS_PWRSTATE_ANA]!==1'b0) begin
      if (Dreg==1'b0) Xin=1;                     // analog LtoX
    end
  end
// Wait for txdel before driving output to X:
  always @(posedge(Xin)) begin :GoToX            // input changed to X
    #(txdig)                                     // wait for X time delay
    if (Xin==1) Dreg=1'bx;                       // goto X if still between
  end

endmodule

// 
// Design File for: (connectLib E2L_2_LPS module)
//
// E2L_2.vams - basic Verilog-AMS elect to logic connection module
// last revised:  01/25/06, jhou
//
// REVISION HISTORY:
// Created:  1/18/04 jhou
// Updated:  1/25/06 jhou - changed default tr to 0.2n
//
// Created:  12/10 nzhang - this connect module is a copy from E2L_2.vams and
//                          specified for AMSLPS.
//                          * add $amslps_power_state_register(iPwrState, vPwrArgArray)
//                            func/task call to check the power status of the drivers
//                            of Ain, and change the output logic if the driver is shutoff.
//

/****************************************************************************
Description:

This electrical-to-logic connect module is designed for better simulation
performance. It supports 4-level logic (0, 1, X, and Z), and has
the following different properties compared to connectmodule E2L:

1, The optimized hysteresis setup between above functions maximizes the
   noise filtering capabilities and hence simulation speed. By default,
   the time tolerance in cross function is 1/4 of transition rise/fall
   time and voltage tolerance is 1/12 of voltage supply.

****************************************************************************/

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO     0
`define AMSLPS_NOMVDD   1
`define AMSLPS_NOMVSS   2
`define AMSLPS_NOMPMOS  3
`define AMSLPS_NOMNMOS  4
`define AMSLPS_ARGSIZE  4

//============================================================================
connectmodule E2L_2_LPS (Ain, Dout);
  input Ain; electrical Ain;                     // electrical input
  output Dout; \logic Dout;                      // logic output

// INSTANCE PARAMETERS:
  parameter real vsup=1.8       from (0:inf);    // nominal supply voltage
  parameter real vthi=vsup/1.5  from (-inf:inf);          // upper threshold
  parameter real vtlo=vsup/3    from (-inf:vthi];          // lower threshold
  parameter real vtol=vsup/12   from (0:(vthi-vtlo)/2]; // voltage tolerance
  parameter real tr=0.2n        from (0:1m];     // risetime (for defaults)
  parameter real txdel=4*tr     from (0:1m];     // time midrange til output X
  parameter real ttol_c=tr/4      from (0:1m];     // time tolerance of crossing
  parameter real vtlox=vtlo+vtol   from (vtlo:vthi);  // lo-to-x threshold point
  parameter real vthix=vthi-vtol   from [vtlox:vthi); // hi-to-x threshold point

// LOCAL VARIABLES:
  reg Dreg;                // output register
  reg Xin;                 // flag if analog is in midrange
  real txdig;              // delay from midlevel to X in timescale units
  wire [31:0] Dval;
  
// LOCAL VARIABLES for AMSLPS:
  reg  iPwrState;                        // register the power state
  real vPwrArgArray[`AMSLPS_ARGSIZE:0];  // voltage value of the nominal condition
  real vpthi, vptlo, vptol;
  real vpthix, vptlox;
  real vAin;

  reg sie;
  
//============================================================================
  initial begin
    txdig=txdel/1n;        // digital delay midlevel to X  (ASSUMES TIMESCALE)
    Dreg=1'b0;             // initial level
    Xin=0;                 // initially not in X delay region.
    $SIE_input(Dout, Dval);   //set digital driver sensitivity
    sie = $strength_resolution(Dout);
    // AMSLPS
    iPwrState = 1'b1;
    vPwrArgArray[`AMSLPS_VPSO]=0.0;
    vPwrArgArray[`AMSLPS_NOMVDD]=vsup;
    vPwrArgArray[`AMSLPS_NOMVSS]=0.0;
    $amslps_power_state_register(iPwrState, vPwrArgArray);
    vpthi = vPwrArgArray[`AMSLPS_NOMVDD]/1.5;
    vptlo = vPwrArgArray[`AMSLPS_NOMVDD]/3;
    vptol = vPwrArgArray[`AMSLPS_NOMVDD]/100;
    vpthix= vpthi-2*vptol;
    vptlox= vptlo+2*vptol;
  end

// AMSLPS
  always @(iPwrState) begin
      // recalculate working voltage
      vpthi = vPwrArgArray[`AMSLPS_NOMVDD]/1.5;
      vptlo = vPwrArgArray[`AMSLPS_NOMVDD]/3;
      vptol = vPwrArgArray[`AMSLPS_NOMVDD]/100;
      vpthix= vpthi-2*vptol;
      vptlox= vptlo+2*vptol;

      if (iPwrState == 1'b0)
          // put shut-off state on analog side
          Dreg=1'bx;
      else begin
          // recover logic state
          vAin = V(Ain);
          if (vAin > vpthi) Dreg=1'b1;
          else if (vAin < vptlo) Dreg=1'b0;
          else Dreg=1'bx;
      end
  end

// Convert analog signal to high/low and X/notX:
  always @(above(V(Ain)-vpthi,ttol_c,vptol)) begin // analog XtoH
      if (iPwrState == 1'b0) Dreg=1'bx;
      else Dreg=1;
      Xin=0; disable GoToX;
  end
  always @(above(vptlo-V(Ain),ttol_c,vptol)) begin // analog XtoL
      if (iPwrState == 1'b0) Dreg=1'bx;
      else Dreg=0;
      Xin=0; disable GoToX;
  end
  always @(above(vpthix-V(Ain),ttol_c,vptol))
      if (Dreg==1'b1) Xin=1;                     // analog HtoX
  always @(above(V(Ain)-vptlox,ttol_c,vptol))
      if (Dreg==1'b0) Xin=1;
// Wait for txdel before driving output to X:
  always @(posedge(Xin)) begin :GoToX            // input changed to X
    #(txdig)                                     // wait for X time delay
    if (Xin==1) Dreg=1'bx;                       // goto X if still between
  end
  assign  Dout=Dreg;                             // assign register to output
endmodule

// 
// Design File for: (connectLib R2L_LPS module)
//
// R2L_LPS.vams - Basic Real to Logic connection module
//
// REVISION HISTORY
// Created: 01/14/11, aspratt
// Created: 01/11, nzhang - this connect module is a copy from L2R.vams and specified for AMSLPS.

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO       0
`define AMSLPS_NOMVDD     1
`define AMSLPS_NOMVSS     2
`define AMSLPS_VPMOSBIAS  3
`define AMSLPS_VNMOSBIAS  4
`define AMSLPS_AEGSIZE    5

// Power Smart R2L connect module
connectmodule R2L_LPS(Rin, Lout);
   output Lout;
   input  Rin; wreal Rin;

   parameter real vsup = 1.8 from (0:inf);      // nominal supply voltage
   parameter real vlo = 0;                      // logic low voltage
   parameter real vhi = vsup from (vlo:vsup];   // logic high voltage
   parameter real vtlo = vsup / 3;              // lower threshold
   parameter real vthi = vsup /1.5;             // upper threshold

   reg R_conv;

   // LOCAL VARIABLES for AMSLPS:
   reg  iPwrState=1;                        // register of the power state
   real vPwrArgArray[`AMSLPS_AEGSIZE-1:0];  // voltages value of the nominal condition

   initial
     begin
        /* set the initial value to Z */
        R_conv = 1'bz;
        /* set the initial value for AMSLPS variables */
        vPwrArgArray[`AMSLPS_NOMVDD]=vhi;
        vPwrArgArray[`AMSLPS_NOMVSS]=vlo;
        vPwrArgArray[`AMSLPS_VPSO]=0.0;
        $amslps_power_state_register(iPwrState, vPwrArgArray);
     end

   // Determine the value of R and convert to a logic value
   always
     begin
        if (iPwrState===1'b0) begin
            R_conv = 1'bx;
        end
        else begin
          if(Rin >= vPwrArgArray[`AMSLPS_NOMVDD]/1.5)
            R_conv = 1'b1;
          else if (Rin <= vPwrArgArray[`AMSLPS_NOMVDD]/3)
            R_conv = 1'b0;
          else if(Rin === `wrealZState)
            R_conv = 1'bz;
          else
            R_conv = 1'bx;
        end
        @(Rin or iPwrState);
     end

   // drive the converted value back onto the output L pin
   assign Lout = R_conv;

endmodule

// 
// Design File for: (connectLib L2R_LPS module)
//
// L2R_LPS.vams - Basic Logic to Real connection module
//
// REVISION HISTORY
// Created: 01/14/11, aspratt
// Created: 01/11, nzhang - this connect module is a copy from L2R.vams and specified for AMSLPS.

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO       0
`define AMSLPS_NOMVDD     1
`define AMSLPS_NOMVSS     2
`define AMSLPS_VPMOSBIAS  3
`define AMSLPS_VNMOSBIAS  4
`define AMSLPS_AEGSIZE    5

// Power Smart L2R connect module
connectmodule L2R_LPS(Rout, Lin);
   input Lin;
   output  Rout; wreal Rout;
   
   parameter real vsup = 1.8 from (0:inf);  // nominal supply voltage
   parameter real vlo = 0;                  // logic low vlotage
   parameter real vhi = vsup from (vlo:vsup];   // logic high voltage

   real L_conv;

   // LOCAL VARIABLES for AMSLPS:
   reg  iPwrState=1;                        // register of the power state
   real vPwrArgArray[`AMSLPS_AEGSIZE-1:0];  // voltages value of the nominal condition

   initial
     begin
        /* set the initial value to Z */
        L_conv = `wrealZState;
        /* set the initial value for AMSLPS variables */
        vPwrArgArray[`AMSLPS_NOMVDD]=vhi;
        vPwrArgArray[`AMSLPS_NOMVSS]=vlo;
        vPwrArgArray[`AMSLPS_VPSO]=`wrealXState;
        $amslps_power_state_register(iPwrState, vPwrArgArray);
     end

   // Determine the value of L and convert to a real value
   always
     begin
       case (Lin)
         1'b0:    L_conv = vPwrArgArray[`AMSLPS_NOMVSS];
         1'b1:    L_conv = vPwrArgArray[`AMSLPS_NOMVDD];
         1'bz:    L_conv = `wrealZState;
         1'bx:    L_conv = (iPwrState===1'b0) ? vPwrArgArray[`AMSLPS_VPSO] : `wrealXState;
         default: L_conv = `wrealXState;
       endcase
       @(Lin or iPwrState);
     end

   // drive the converted value back onto the output R pin
   assign Rout = L_conv;

endmodule

// 
// Design File for: (connectLib RL_Bidir_LPS module)
//
// RL_Bidir_LPS.vams - Basic Real to Logic bidirectional connection module
//
// REVISION HISTORY
// Created: 01/14/11, aspratt
// Created: 01/11, nzhang - this connect module is a copy from L2R.vams and specified for AMSLPS.

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO       0
`define AMSLPS_NOMVDD     1
`define AMSLPS_NOMVSS     2
`define AMSLPS_VPMOSBIAS  3
`define AMSLPS_VNMOSBIAS  4
`define AMSLPS_AEGSIZE    5
`define AMSLPS_PWRSTATE_DIG 0
`define AMSLPS_PWRSTATE_ANA 1

// Power Smart RL_Bidir connect module
connectmodule RL_Bidir_LPS(R, L);
   inout L;
   inout R; wreal R;

   parameter real vsup = 1.8 from (0:inf);      // nominal supply voltage
   parameter real vlo = 0;                      // logic low voltage
   parameter real vhi = vsup from (vlo:vsup];   // logic high voltage
   parameter real vtlo = vsup / 3;              // lower threshold
   parameter real vthi = vsup /1.5;             // upper threshold

   wreal       R_val;
   reg         R_conv;
   wire [1:0]  L_val;
   real        L_conv;

   // LOCAL VARIABLES for AMSLPS:
   reg  [1:0]iPwrState=2'b11;               // register the power state
   real vPwrArgArray[`AMSLPS_AEGSIZE-1:0];  // voltages value of the nominal condition

   initial
     begin
        /* set the initial value to Z */
        $input_logic_value(L, L_val); // set logic driver sensitivity
        $input_real_value(R, R_val);  // set real driver sensitivity
        R_conv = 1'bz;
        L_conv = `wrealZState;
        /* set the initial value for AMSLPS variables */
        vPwrArgArray[`AMSLPS_NOMVDD]=vhi;
        vPwrArgArray[`AMSLPS_NOMVSS]=vlo;
        vPwrArgArray[`AMSLPS_VPSO]=`wrealXState;
        $amslps_power_state_register(iPwrState, vPwrArgArray);
     end

   // Determine the value of R and convert to a logic value
   always
     begin
        if (iPwrState[`AMSLPS_PWRSTATE_ANA]===1'b0) begin
            R_conv = 1'bx;
        end
        else begin
          if(R_val >= vPwrArgArray[`AMSLPS_NOMVDD]/1.5)
            R_conv = 1'b1;
          else if (R_val <= vPwrArgArray[`AMSLPS_NOMVDD]/3)
            R_conv = 1'b0;
          else if(R_val === `wrealZState)
            R_conv = 1'bz;
          else
            R_conv = 1'bx;
        end
        @(R_val or iPwrState);
     end

   // Determine the value of L and convert to a real value
   always
     begin
       case (L_val)
         2'b00: L_conv = vPwrArgArray[`AMSLPS_NOMVSS];
         2'b01: L_conv = vPwrArgArray[`AMSLPS_NOMVDD];
         2'b10: L_conv = `wrealZState;
         2'b11: begin
             if (iPwrState[`AMSLPS_PWRSTATE_DIG]===1'b0)
                L_conv = vPwrArgArray[`AMSLPS_VPSO];
             else
                L_conv = `wrealXState;
         end
       endcase
       @(L_val or iPwrState);
     end


   // drive the converted value back onto the output R pin
   assign R = L_conv;
   
   // drive the converted value back onto the output L pin
   assign L = R_conv;

endmodule

// 
// Design File for: (connectLib E2R_LPS module)
//
// E2R.vams - basic Verilog-AMS electrical to discrete wreal connection module
// last revised:  08/01/06, jhou
//
// REVISION HISTORY:
// Created:  08/01/06, jhou

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO       0
`define AMSLPS_NOMVDD     1
`define AMSLPS_NOMVSS     2
`define AMSLPS_VPMOSBIAS  3
`define AMSLPS_VNMOSBIAS  4
`define AMSLPS_WPSO       5
`define AMSLPS_AEGSIZE    5

connectmodule E2R_LPS (Ain, Dout);
input Ain;
electrical Ain;    //input electrical
output Dout;
wreal Dout;        //output wreal
\logic Dout;       //discrete domain

  parameter real vdelta=1.8/64   from (0:inf);    // voltage delta
  parameter real vtol=vdelta/4   from (0:vdelta); // voltage tolerance
  parameter real ttol=10p        from (0:1m];     // time tolerance
  parameter integer currentmode=0  from [0:0];	    // current mode is not supported in LPS

  real Dreg;       //real register for A to D wreal conversion

  reg sie;
  // LOCAL VARIABLES for AMSLPS:
  reg  iPwrState=1;                        // register of the power state
  real vPwrArgArray[`AMSLPS_AEGSIZE:0];  // voltages value of the nominal condition

//============================================================================
  initial begin
    sie = $strength_resolution(Dout);
    /* set the initial value for AMSLPS variables */
    vPwrArgArray[`AMSLPS_VPSO]=0.2;
    vPwrArgArray[`AMSLPS_WPSO]=`wrealXState;
    vPwrArgArray[`AMSLPS_NOMVDD]=0;
    vPwrArgArray[`AMSLPS_NOMVSS]=0;
    $amslps_power_state_register(iPwrState, vPwrArgArray);
  end

  assign Dout = Dreg;

  //discretize V(Ain) triggered by absdelta function
  always @(absdelta(V(Ain), vdelta, ttol, vtol) or iPwrState) begin
    if (iPwrState===1'b0)
      Dreg = vPwrArgArray[`AMSLPS_WPSO];
    else
      Dreg = V(Ain);
  end

endmodule


// 
// Design File for: (connectLib R2E_2_LPS module)
//
// R2E_2.vams - Efficient Verilog-AMS discrete wreal to electrical connection module
//
// REVISION HISTORY:
// Created:  09/01/08, gangchen

`include "disciplines.vams"
`timescale 1ns / 1ps
 
`define AMSLPS_VPSO     0
`define AMSLPS_NOMVDD   1
`define AMSLPS_NOMVSS   2
`define AMSLPS_NOMPMOS  3
`define AMSLPS_NOMNMOS  4
`define AMSLPS_WPSO     5
`define AMSLPS_ARGSIZE  5

connectmodule R2E_2_LPS (Din, Aout);
  input Din;
  wreal Din;		// input wreal
  \logic Din;
  output Aout;
  electrical Aout;	// output electrical

  parameter real vsup = 1.8		from (0:inf);	// supply voltage
  parameter real vdelta = vsup/64 from (0:vsup];	// voltage delta
  parameter real vlo = 0;
  parameter real vx = vlo		from [0:vsup];	// X output voltage
  parameter real tr = 10p		from (0:inf);	// risetime of analog output
  parameter real tf = tr		from (0:inf);	// falltime of analog output
  parameter real ttol_t = (tr+tf)/20 from (0:inf); // time tol of transition
  parameter real tdelay = 0		from [0:inf);	// delay time of analog output
  parameter real rout = 200		from (0:inf);	// output resistance
  parameter real rx = rout		from (0:inf);	// X output resistance
  parameter real rz = 10M		from (0:inf);	// Z output resistance
  // INSTANCE PARAMETERS for AMSLPS:
  parameter real    vpso=0.2;                 // X output voltage
  parameter integer currentmode=0  from [0:0];	    // current mode is not supported in LPS
  real Vstate, Rstate;
  real Vout, Rout;
  reg sie;

  reg  iPwrState;                        // register the power state
  real vPwrArgArray[`AMSLPS_ARGSIZE:0];  // voltage value of the nominal condition

  initial begin
    if (Din === `wrealXState)
      begin Vstate = vx; Rstate = rx; end
    else if (Din === `wrealZState)
      begin Vstate = vlo; Rstate = rz; end
    else
      begin Vstate = Din; Rstate = rout; end
    sie = $strength_resolution(Din);
    iPwrState = 1'b1;
    vPwrArgArray[`AMSLPS_VPSO]=vpso;
    vPwrArgArray[`AMSLPS_WPSO]=`wrealXState;
    vPwrArgArray[`AMSLPS_NOMVDD]=vsup;
    vPwrArgArray[`AMSLPS_NOMVSS]=0;
    $amslps_power_state_register(iPwrState, vPwrArgArray);
  end

  always @(Din or iPwrState) begin
    if (iPwrState==1'b0) begin
        Vstate=vPwrArgArray[`AMSLPS_VPSO];
        Rstate = rx;
    end
    else begin
      if (Din === `wrealXState)
        begin Vstate = vx; Rstate = rx; end
      else if (Din === `wrealZState)
        begin Rstate = rz; end
      else if (Din-Vstate >= vdelta || Vstate-Din >= vdelta)
        begin Vstate = Din; Rstate = rout; end
    end
  end

  assign Din = sie? `wrealZState : Din;

  analog begin
    Vout = transition(Vstate, tdelay, tr, tf, ttol_t);
    Rout = transition(Rstate, tdelay, tr, tf, ttol_t);
    I(Aout) <+ (V(Aout) - Vout) / Rout;
  end

endmodule

// 
// Design File for: (connectLib ER_Bidir_LPS module)
//
// ER_bidir.vams - basic Verilog-AMS connection module for electrical
// and discrete wreal bidirectional conversion
// last revised:  08/29/06, jhou
//
// REVISION HISTORY:
// Created:  08/29/06, jhou

`include "disciplines.vams"
`timescale 1ns / 1ps

`define AMSLPS_VPSO     0
`define AMSLPS_NOMVDD   1
`define AMSLPS_NOMVSS   2
`define AMSLPS_NOMPMOS  3
`define AMSLPS_NOMNMOS  4
`define AMSLPS_WPSO     5
`define AMSLPS_ARGSIZE  5
`define AMSLPS_PWRSTATE_DIG 0
`define AMSLPS_PWRSTATE_ANA 1

connectmodule ER_Bidir_LPS (Din, Aout);
inout Din;
wreal Din;         //inout wreal
\logic Din;        //discrete domain
inout Aout;
electrical Aout;   //inout electrical

  parameter real vdelta=1.8/64   from (0:inf); // voltage delta
  parameter real vtol=vdelta/4   from (0:vdelta); // voltage tolerance
  parameter real ttol=10p        from (0:1m];     // time tolerance
  parameter real tr=10p          from (0:1m);  // risetime
  parameter real tf=tr           from (0:1m);  // falltime
  parameter real tdelay=0        from [0:1m);  // delay time of analog output
  parameter real rout=200        from (0:inf); // output resistance
  parameter real rz=10M          from (0:inf); // open resistance
  // INSTANCE PARAMETERS for AMSLPS:
  parameter real    vpso=0.2;                 // X output voltage
  parameter integer currentmode=0  from [0:0];	    // current mode is not supported in LPS
  
  real Dreg;       //real register for A to D wreal conversion
  real Vstate;     //real register for D wreal to A conversion
  real Rout;       //output resistance

  integer D_count = 0;

  reg sie;

  reg  [1:0]iPwrState;                   // register the power state
  real vPwrArgArray[`AMSLPS_ARGSIZE:0];  // voltage value of the nominal condition

  wreal R_val;
  wreal D_val;
  wire  P_val;

  initial begin
        Vstate = 0;
        $input_real_value(Din, R_val);
        D_count = $driver_count(Din);
        Rout = rz;
        Dreg = `wrealZState;
        sie = $strength_resolution(Din);
        // AMSLPS
        iPwrState = 2'b11;
        vPwrArgArray[`AMSLPS_VPSO]=vpso;
        vPwrArgArray[`AMSLPS_WPSO]=`wrealXState;
        vPwrArgArray[`AMSLPS_NOMVDD]=0;
        vPwrArgArray[`AMSLPS_NOMVSS]=0;
        $amslps_power_state_register(iPwrState, vPwrArgArray);
  end

  assign D_val = sie?R_val:Din;
  assign P_val = iPwrState[0];

  always @(D_val or iPwrState) begin
      if (((sie && (D_val === `wrealZState || D_count == 1))) || (!sie && (D_val === `wrealZState || D_count == 0))) begin
          Rout = rz;
      end
      else if (iPwrState[`AMSLPS_PWRSTATE_DIG]==1'b0) begin
          Vstate=vPwrArgArray[`AMSLPS_VPSO];
      end
      else if (iPwrState[`AMSLPS_PWRSTATE_DIG] != P_val) begin
          Vstate = Din;
      end
      else begin
      //filter out digital noise within +/-vdelta
      if (D_val-Vstate>=vdelta || Vstate-D_val>=vdelta) begin
        Vstate = D_val;
        Rout = rout;
      end
      end
  end

  //discretize V(Aout) triggered by absdelta function
  always @(absdelta(V(Aout), vdelta, ttol, vtol) or iPwrState) begin
    if ( (sie && (D_val === `wrealZState || D_count == 1)) || !sie ) begin
      if (iPwrState[`AMSLPS_PWRSTATE_ANA]==1'b0)
        Dreg =vPwrArgArray[`AMSLPS_WPSO];
      else
        Dreg = V(Aout);
    end
end

  assign Din = Dreg;

  analog begin
        I(Aout) <+ (V(Aout) - transition(Vstate, tdelay, tr, tf))/Rout;
  end

endmodule

// 
// Design File for: (connectLib ConnRules_18V_full_fast connect)
//
// 'ConnRules_18V.vams' - Verilog-AMS 1.8 volt connection rules file.
// last revised:  01/25/06 (jhou)
//
// REVISION HISTORY:
// Created:  10/22/02 (ronv)
// Updated:  01/25/06 (jhou) - Added ConnRules_18V_full_fast.
// Updated:  08/08/06 (jhou) - Added electrical-wreal connectmodules.
// Updated:  09/08/06 (jlz)  - Added include disciplines.vams so electrical
//                             discipline is available for AMSVF flow.


// This line is added to make sure that all connect rules are 
// defined by default When ncverilog is run with
// +define+CDS_SELECT_CRS, the connect rules are defined
// selectively based on other +define settings that are sent to 
// ncverilog

`ifndef CDS_SELECT_CRS
`define CONNRULES_18V_FULL_FAST
`define CONNRULES_18V_FULL
`define CONNRULES_18V_MID
`define CONNRULES_18V_BASIC
`define CONNRULES_FULL_FAST
`define CONNRULES_FULL
`define CONNRULES_MID
`define CONNRULES_BASIC
`endif

// This file is a template for definition of rules for a particular 
// logic family.  Values for some typical parameters are defined here,
// then used in the three sets of connections rules below.
// See the "README.txt" file for a more complete usage description.

`include "disciplines.vams"

`define Vsup  1.8
`define Vthi  1.2
`define Vtlo  0.6
`define Vlow  0
`define Tr    0.2n
`define Rlo   200
`define Rhi   200
`define Rx    40
`define Rz    10M
`define Vdelta      `Vsup/64
`define Vdelta_tol  `Vdelta/4
`define Tr_delta    `Tr/20
`define rsupply     4
`define rpull       1.5e3
`define rlarge      9.0e3
`define rweak       5.5e4
`define rmedium     3.2e5
`define rsmall      1.9e6

`ifdef CONNRULES_18V_FULL_FAST
connectrules ConnRules_18V_full_fast;
  connect L2E_2 #(
      .vsup(`Vsup), .vlo(`Vlow),
      .tr(`Tr), .tf(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz),
      .r_SUPPLY(`rsupply), .r_PULL(`rpull),
      .r_LARGE(`rlarge), .r_WEAK(`rweak), .r_MEDIUM(`rmedium),
      .r_SMALL(`rsmall) );
  connect E2L_2 #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect Bidir_2 #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .vlo(`Vlow),
      .tr(`Tr), .tf(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz),
      .r_SUPPLY(`rsupply), .r_PULL(`rpull),
      .r_LARGE(`rlarge), .r_WEAK(`rweak), .r_MEDIUM(`rmedium),
      .r_SMALL(`rsmall) );
  connect E2R #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_2 #(.vsup(`Vsup), .vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_bidir #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz));
  //Real-2-Logic
  connect R2L #(.vsup(`Vsup), .vlo(`Vlow), .vtlo(`Vtlo), .vthi(`Vthi)) logic, logic;
  connect L2R #(.vsup(`Vsup), .vlo(`Vlow)) logic, logic;
  connect RL_bidir #(.vsup(`Vsup), .vlo(`Vlow), .vtlo(`Vtlo), .vthi(`Vthi)) logic, logic;
  // AMSLPS
  connect L2E_2_LPS #(
      .vsup(`Vsup), .vlo(`Vlow),
      .tr(`Tr), .tf(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz) );
  connect Bidir_2_LPS #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo),
      .tr(`Tr), .tf(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz) );
  connect E2L_2_LPS #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect R2L_LPS #(.vsup(`Vsup), .vlo(`Vlow), .vtlo(`Vtlo), .vthi(`Vthi)) logic, logic;
  connect L2R_LPS #(.vsup(`Vsup), .vlo(`Vlow)) logic, logic;
  connect RL_Bidir_LPS #(.vsup(`Vsup), .vlo(`Vlow), .vtlo(`Vtlo), .vthi(`Vthi)) logic, logic;
  connect E2R_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_2_LPS #(.vsup(`Vsup), .vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_Bidir_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz));
endconnectrules
`endif

`ifdef CONNRULES_18V_FULL
connectrules ConnRules_18V_full;
  connect L2E #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .vlo(`Vlow),
      .tr(`Tr), .tf(`Tr), .tx(`Tr), .tz(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz),
      .r_SUPPLY(`rsupply), .r_PULL(`rpull),
      .r_LARGE(`rlarge), .r_WEAK(`rweak), .r_MEDIUM(`rmedium),
      .r_SMALL(`rsmall) );
  connect E2L #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect Bidir #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .vlo(`Vlow),
      .tr(`Tr), .tf(`Tr), .tx(`Tr), .tz(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz),
      .r_SUPPLY(`rsupply), .r_PULL(`rpull),
      .r_LARGE(`rlarge), .r_WEAK(`rweak), .r_MEDIUM(`rmedium),
      .r_SMALL(`rsmall) );
  connect E2R #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_2 #(.vsup(`Vsup), .vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_bidir #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz)); 
  // AMSLPS
  connect L2E_LPS #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .vlo(`Vlow),
      .tr(`Tr), .tf(`Tr), .tx(`Tr), .tz(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz) );
  connect Bidir_LPS #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo),
      .tr(`Tr), .tf(`Tr), .tx(`Tr), .tz(`Tr),
      .rlo(`Rlo), .rhi(`Rhi), .rx(`Rx), .rz(`Rz) );
  connect E2L_LPS #(
      .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect E2R_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_2_LPS #(.vsup(`Vsup), .vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_Bidir_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz)); 
endconnectrules
`endif

`ifdef CONNRULES_18V_MID
connectrules ConnRules_18V_mid;
  connect E2L #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect L2E_1 #( .vsup(`Vsup), .tr(`Tr), .vlo(`Vlow), .rout(`Rlo) );
  connect Bidir_0 #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .vlo(`Vlow),
                   .tr(`Tr), .rout(`Rlo) );
  connect E2R #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_0 #(.vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_bidir #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz)); 
  // AMSLPS
  connect L2E_1_LPS #( .vsup(`Vsup), .tr(`Tr), .vlo(`Vlow), .rout(`Rlo) );
  connect Bidir_0_LPS #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo),
                   .tr(`Tr), .rout(`Rlo) );
  connect E2L_LPS #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect E2R_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_0_LPS #(.vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_Bidir_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz)); 
endconnectrules
`endif

`ifdef CONNRULES_18V_BASIC
connectrules ConnRules_18V_basic;
  connect E2L_0 #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect L2E_0 #( .vsup(`Vsup), .vlo(`Vlow), .tr(`Tr), .rout(`Rlo) );
  connect Bidir_0 #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .vlo(`Vlow),
                   .tr(`Tr), .rout(`Rlo) );
  connect E2R #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_0 #(.vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_bidir #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz)); 
  // AMSLPS
  connect L2E_0_LPS #( .vsup(`Vsup), .vlo(`Vlow), .tr(`Tr), .rout(`Rlo) );
  connect Bidir_0_LPS #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo),
                   .tr(`Tr), .rout(`Rlo) );
  connect E2L_0_LPS #( .vsup(`Vsup), .vthi(`Vthi), .vtlo(`Vtlo), .tr(`Tr) );
  connect E2R_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta)); 
  connect R2E_0_LPS #(.vdelta(`Vdelta), .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo)); 
  connect ER_Bidir_LPS #(.vdelta(`Vdelta), .vtol(`Vdelta_tol), .ttol(`Tr_delta),
        .tr(`Tr_delta), .tf(`Tr_delta), .rout(`Rlo), .rz(`Rz)); 
endconnectrules
`endif

//////////////  CONNECT RULES WITH DEFAULT PARAMETERS  //////////////
//  Here are connection rules that use the default parameters in the 
//  connection modules themselves (if you edit the connect modules instead
//  of editing the descriptions above, you can then use these rules):

`ifdef CONNRULES_FULL_FAST
connectrules ConnRules_full_fast;
  connect L2E_2;
  connect E2L_2;
  connect Bidir_2;
  connect E2R; 
  connect R2E_2; 
  connect ER_bidir; 
  connect L2E_2_LPS;
  connect Bidir_2_LPS;
  connect E2L_2_LPS;
  connect E2R_LPS; 
  connect R2E_2_LPS; 
  connect ER_Bidir_LPS; 
endconnectrules
`endif

`ifdef CONNRULES_FULL
connectrules ConnRules_full;
  connect L2E;
  connect E2L;
  connect Bidir;
  connect E2R; 
  connect R2E_2; 
  connect ER_bidir; 
  connect L2E_LPS;
  connect Bidir_LPS;
  connect E2L_LPS;
  connect E2R_LPS; 
  connect R2E_2_LPS; 
  connect ER_Bidir_LPS; 
endconnectrules
`endif

`ifdef CONNRULES_MID
connectrules ConnRules_mid;
  connect E2L_0;
  connect L2E_0;
  connect Bidir_0;
  connect E2R; 
  connect R2E_0; 
  connect ER_bidir; 
  connect L2E_0_LPS;
  connect Bidir_0_LPS;
  connect E2L_0_LPS;
  connect E2R_LPS; 
  connect R2E_0_LPS; 
  connect ER_Bidir_LPS; 
endconnectrules
`endif

`ifdef CONNRULES_BASIC
connectrules ConnRules_basic;
  connect E2L;
  connect L2E_1;
  connect Bidir_0;
  connect E2R; 
  connect R2E_0; 
  connect ER_bidir; 
  connect L2E_1_LPS;
  connect Bidir_0_LPS;
  connect E2L_LPS;
  connect E2R_LPS; 
  connect R2E_0_LPS; 
  connect ER_Bidir_LPS; 
endconnectrules
`endif


// 
// Design File for: (16nm_Tests cds_globals MC_6TWrite_Test_ams_config)
//
// Verilog-AMS cds_globals module for top-level cell:
//    16nm_Tests/MC_6TWrite_Test.
// Generated by ADE.
// Cadence Design Systems, Inc.

// This is an autoGenerated file, any changes done to this file may get lost.

`include "disciplines.vams"
`include "userDisciplines.vams"

module cds_globals;

// Global Signals
   electrical \gnd! ;
   ground \gnd! ;
   wire \vdd! ;
   wire \vcc! ;

// Design Variables
   dynamicparam real time2 = 2n;
   dynamicparam real time3 = 2.22n;
   dynamicparam real time4 = 2.85n;
   dynamicparam real time5 = 3n;
   dynamicparam real vdd = 0.500;

endmodule

// This is the Cadence AMS Designer(R) analog simulation control file. 
// It specifies the options and analyses for the Spectre analog solver. 

simulator lang=spectre 

simulatorOptions options temp=27 tnom=27 scale=1.0 scalem=1.0 reltol=1e-3 \
vabstol=1e-6 iabstol=1e-12 gmin=1e-12 rforce=1 maxnotes=5 maxwarns=5 \
digits=5 pivrel=1e-3 checklimitdest=psf 

tran tran stop=4n errpreset=conservative save=none write="spectre.ic" \
writefinal="spectre.fc" annotate=status maxiters=5 

finalTimeOP info what=oppoint where=rawfile

modelParameter info what=models where=rawfile 
element info what=inst where=rawfile 
outputParameter info what=output where=rawfile 

# This is the NC-SIM(R) probe command file
# used in the AMS-ADE integration.


#
# Database settings
#
if { [info exists ::env(AMS_RESULTS_DIR) ] } { set AMS_RESULTS_DIR $env(AMS_RESULTS_DIR)} else {set AMS_RESULTS_DIR "../psf"}
database -open ams_database -into ${AMS_RESULTS_DIR} -default

#
# Probe settings
#
probe -create -emptyok -database ams_database {MC_6TWrite_Test.Aline[0]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.S[0]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.W1_1[3]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.W1_1[2]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.W1_1[1]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.W1_1[0]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.B1_1[3]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.B1_1[2]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.B1_1[1]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.B1_1[0]}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.ICHUNK.IARRAY0.ISRAM0.I7.I3.Q1}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.ICHUNK.IARRAY0.ISRAM0.I7.I3.Q0}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.ICHUNK.IARRAY0.B1P1}
probe -create -emptyok -database ams_database {MC_6TWrite_Test.ICHUNK.IARRAY0.B0P1}

